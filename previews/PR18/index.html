<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · AdmissionsSimulation.jl</title><link rel="canonical" href="https://timholy.github.io/AdmissionsSimulation.jl/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">AdmissionsSimulation.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Applicant-records"><span>Applicant records</span></a></li><li><a class="tocitem" href="#Match-criteria"><span>Match criteria</span></a></li><li><a class="tocitem" href="#Analysis-and-simulations"><span>Analysis and simulations</span></a></li><li><a class="tocitem" href="#API-reference"><span>API reference</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/timholy/AdmissionsSimulation.jl/blob/master/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="AdmissionsSimulation"><a class="docs-heading-anchor" href="#AdmissionsSimulation">AdmissionsSimulation</a><a id="AdmissionsSimulation-1"></a><a class="docs-heading-anchor-permalink" href="#AdmissionsSimulation" title="Permalink"></a></h1><p><a href="https://github.com/timholy/AdmissionsSimulation.jl">AdmissionsSimulation</a> is designed to simulate outcomes of graduate admissions, with the intent of helping make decisions about both initial offers and wait-list offers.</p><p>This package focuses on those students to whom offers of admission have been extended, and uses past applicants as proxies for current applicants to make predictions about whether they&#39;ll accept the offer. Because two &quot;similar&quot; students might end up making different final decisions, the recommended practice is to identify many different potential proxies and use the distribution of their decisions to simulate future outcomes.  This is similar to a <a href="https://en.wikipedia.org/wiki/K-nearest_neighbors_algorithm">k-nearest neighbors</a> algorithm, but with continuous weights applied to each potential neighbor and no limit on the number of neighbors used.</p><p>The inputs to this process are:</p><ul><li>records on previous applicants</li><li>criteria for deciding the similarity between two students, resulting in a matching function computing a value between 0 (no match) and 1 (a perfect match).</li></ul><p>The core concept may be easily explained by a simplified example. Imagine that the admissions committee for &quot;program A&quot; has ranked their applicants for the season. Let&#39;s focus on one &quot;test&quot; applicant, say their 2nd most highly-ranked applicant. Let&#39;s imagine that the history of past admissions seasons looks like the first four columns below:</p><table><tr><th style="text-align: left">Applicant</th><th style="text-align: left">Program</th><th style="text-align: right">Applicant rank</th><th style="text-align: right">Accepted?</th><th style="text-align: right"><em>Similarity to test applicant</em></th></tr><tr><td style="text-align: left">PastApplicant1</td><td style="text-align: left">A</td><td style="text-align: right">1</td><td style="text-align: right">no</td><td style="text-align: right">0.6</td></tr><tr><td style="text-align: left">PastApplicant2</td><td style="text-align: left">A</td><td style="text-align: right">2</td><td style="text-align: right">yes</td><td style="text-align: right">1.0</td></tr><tr><td style="text-align: left">PastApplicant3</td><td style="text-align: left">A</td><td style="text-align: right">3</td><td style="text-align: right">no</td><td style="text-align: right">0.6</td></tr><tr><td style="text-align: left">PastApplicant4</td><td style="text-align: left">A</td><td style="text-align: right">4</td><td style="text-align: right">yes</td><td style="text-align: right">0.4</td></tr><tr><td style="text-align: left">PastApplicant5</td><td style="text-align: left">B</td><td style="text-align: right">1</td><td style="text-align: right">yes</td><td style="text-align: right">0.1</td></tr><tr><td style="text-align: left">PastApplicant6</td><td style="text-align: left">B</td><td style="text-align: right">2</td><td style="text-align: right">no</td><td style="text-align: right">0.15</td></tr></table><p>The final column is specific to this particular &quot;test&quot; applicant–the one being made an offer in the current season whose response to the offer of admission is currently unknown–and must be recomputed for each current applicant we want to examine. The idea is that we look at all previous applicants who were also offered admission and assess similarity. In this table, 4 of the applicants are also from &quot;program A.&quot; These are viewed as being especially similar to the test applicant, particularly the applicant who was also the 2nd most highly-ranked applicant in zir year (with a similarity score of &quot;1.0&quot;). However, in this case our matching function also allows us to use &quot;intelligence&quot; from other programs, and so two applicants to &quot;program B&quot; have a small but nonzero similarity to the test applicant.</p><p>Now, to make predictions about how our test student will respond to our offer, we form a similarity-weighted sum of the previous yes/no decisions. In this case, the probability of &quot;yes&quot; is (1.0 + 0.4 + 0.1)/(0.6 + 1.0 + 0.6 + 0.4 + 0.1 + 0.15) ≈ 0.53. This gives us a quantitative assessment of the likelihood that our test applicant will accept our offer. While each individual applicant must ultimately answer either yes or no, the fundamental thesis of this package is that having a per applicant matriculation probability can allow better control over class sizes through management of offer-extensions and wait-lists.</p><p>The actual model incorporates more factors than shown in this simplified example. For example, we track the date on which each past applicant informed us of zir decision. This allows us to account for the ways in which both applicant and program competitiveness may interact to lead some applicants to respond immediately to our offer of admission and others to wait until the last day of the season (typically April 15th), with the reasons for delay also being coupled to the likelihood of accepting the offer of admission (e.g., more &quot;yes&quot; decisions arrive early and more &quot;no&quot; decisions arrive late). Accounting for these additional factors in our similarity computation improves accuracy in the projections for managing the wait list.</p><p>The remainder of this documentation describes the actual implementation.</p><h2 id="Applicant-records"><a class="docs-heading-anchor" href="#Applicant-records">Applicant records</a><a id="Applicant-records-1"></a><a class="docs-heading-anchor-permalink" href="#Applicant-records" title="Permalink"></a></h2><p>Records on previous applicants are in two forms: very general information is stored in <code>program_history</code>, a dictionary recording just a few bits of information for each program. For example:</p><pre><code class="language-julia">    program_history = Dict(ProgramKey(season=2021, program=&quot;NS&quot;) =&gt; ProgramData(slots=15, napplicants=302, firstofferdate=Date(&quot;2021-01-13&quot;), lastdecisiondate=Date(&quot;2021-04-15&quot;)),
                           ProgramKey(season=2021, program=&quot;CB&quot;) =&gt; ProgramData(slots=5,  napplicants=160, firstofferdate=Date(&quot;2021-01-6&quot;),  lastdecisiondate=Date(&quot;2021-04-15&quot;)))
</code></pre><p>suffices to record aggregate data for two programs, <code>&quot;NS&quot;</code> and <code>&quot;CB&quot;</code>, during the 2021 season (corresponding to a decision deadline of April 15, 2021). This records the target number of matriculants (<code>slots</code>), the total number of applications received, the date of the very first offers extended, and the date on which a decision was due.</p><p>Valid choices for program names are listed in <code>AdmissionsSimulation.program_lookups</code>; internally the code always uses the abbreviation, but it is possible to supply it in long form too.</p><p>Detailed applicant records only need to include applicants to whom an offer of admission was extended. The requirements are described by <a href="#AdmissionsSimulation.NormalizedApplicant"><code>NormalizedApplicant(applicant; program_history)</code></a>.</p><p>You can load both the program history and data on applicants using <a href="#AdmissionsSimulation.read_program_history-Tuple{AbstractString}"><code>read_program_history</code></a> and <a href="#AdmissionsSimulation.read_applicant_data-Tuple{AbstractString}"><code>read_applicant_data</code></a>.</p><h2 id="Match-criteria"><a class="docs-heading-anchor" href="#Match-criteria">Match criteria</a><a id="Match-criteria-1"></a><a class="docs-heading-anchor-permalink" href="#Match-criteria" title="Permalink"></a></h2><p>Applicants 1 and 2 are matched by the following function:</p><p class="math-container">\[\phi(p_1, p_2) \psi(r_1-r_2, t_1-t_2)\]</p><p><span>$\phi(p_1, p_2)$</span> is a measure of similarity between the two applicants&#39; programs, <span>$p_1$</span> and <span>$p_2$</span>, based on program selectivity and yield. The <span>$\psi$</span> term is applicant-specific, analyzing rank <span>$r$</span> and date <span>$t$</span> on which the offer of admission was made.</p><p>In the current implementation, programs are compared by selectivity <span>$s$</span> and yield <span>$y$</span>. Selectivity is simply the fraction of applicants who receive offers of admission; yield is more complicated, because the proper handling of the wait list requires not just an estimate of how many applicants accept our offer, but also the typical timing with which they accept.  A program that ranks first in the world (or one whose admissions committee targets a lot of high-certainty applicants to reduce their risk of receiving rejections) might imagine receiving a lot of &quot;yes&quot; replies as soon as offers are extended, whereas a program with a lot of competition might have a larger number of delayed responses.  Consequently, by default the admissions season is broken into thirds, and the fraction of accepts/declines in each third is the basis for comparing yield in two programs. The formula for doing this is</p><p class="math-container">\[\phi(p_1, p_2) = \exp\left(-\frac{(s_1 - s_2)^2}{2\sigma_\text{sel}^2} - \frac{({\bf y}_1 - {\bf y}_2)^2}{2\sigma_\text{yield}^2}\right).\]</p><p>Here, <span>${\bf y}$</span> is a vector encoding the fraction of accepts/declines in each period of the season, and a Euclidean distance is computed.</p><p>The <span>$\sigma$</span> parameters measure the standard deviation, i.e., the tolerance for mismatch (larger <span>$\sigma$</span> are more tolerant of mismatch). In the extreme of <span>$\sigma \ll 1$</span>, each program matches only itself; in the extreme <span>$\sigma \gg 1$</span>, each program matches every other program perfectly.  In between, programs will draw more &quot;intelligence&quot; from other programs with similar selectivity and yield dynamics as their own. In practice, model-tuning (see below) seems to favor programs primarily relying on their own history.</p><p>The remaining terms are applicant-, rather than program-, specific:</p><p class="math-container">\[\psi(r_1-r_2, t_1-t_2) = \exp\left( - \frac{(r_1 - r_2)^2}{2 \sigma_r^2} - \frac{(t_1 - t_2)^2}{2 \sigma_t^2}\right)\]</p><p><span>$r$</span> refers to the normalized ranks and <span>$t$</span> to the normalized offer date. Smaller <span>$\sigma_r$</span> increases the importance of choosing applicants of similar rank, and would indicate that there may be a strong rank-dependent element to recruitment (e.g., &quot;more competitive applicants are harder to recruit&quot;). Smaller <span>$\sigma_t$</span> increases the importance of the timing of the offer, and would indicate that wait-list offers should be treated quite differently from initial offers. The units of both <span>$\sigma$</span> parameters are those of the <code>NormalizedApplicant</code>s, i.e., with values ranging between 0 and 1. For example, setting <span>$\sigma_t = 0.2$</span> would, in essence, break the decision period (e.g., mid-January to April 15th) into roughly 5 periods, and match primarily against applicants who were extended offers during the same period; conversely, setting <span>$\sigma_t = 5$</span> would mean that the timing of the offer is essentially irrelevant to predicting the decision. Note that the applicant ranks will typically be quite heavily weighted to low values (e.g., a program that only accepts the top 20% of applicants will only exhibit ranks between 0.0 and 0.2), and as a consequence <span>$\sigma_r$</span> must be smaller than this span to have large effect.</p><p>One crucial point is that <em>the matching function returns zero when comparing against past applicants who had already returned their decision by this point in the admissions season</em>. This models the currently-undecided applicants solely in terms of prior applicants who were also undecided at this point. See <a href="#AdmissionsSimulation.match_function-Tuple{}"><code>match_function</code></a> for specific details.</p><p>How does one tune these parameters? The core idea is to train them based on past admissions seasons: if you have records extending back several years, you make matriculation predictions for year <span>$y$</span> based on data from all years up to and including year <span>$y-1$</span>, and then compute a correlation with the actual outcome. See <a href="#AdmissionsSimulation.match_correlation-NTuple{4, AbstractVector{T} where T}"><code>match_correlation</code></a> for details.</p><h2 id="Analysis-and-simulations"><a class="docs-heading-anchor" href="#Analysis-and-simulations">Analysis and simulations</a><a id="Analysis-and-simulations-1"></a><a class="docs-heading-anchor-permalink" href="#Analysis-and-simulations" title="Permalink"></a></h2><p>Once you&#39;ve entered student records and defined a matching function, then for each outstanding offer you can compute the match likelihood of previous applicants using <a href="#AdmissionsSimulation.match_likelihood-Tuple{Function, AbstractVector{NormalizedApplicant}, NormalizedApplicant, Dates.Date}"><code>match_likelihood</code></a>. The sum of the returned list is a rough measure of the &quot;number&quot; of prior applicants deemed to be a good match for the applicant you are modeling; if this value is small, your criteria for matching may be too stringent. Conversely, if this value is approximately equal to the total number of prior applicants, you&#39;re essentially treating all students as equivalent (and matching all of them).</p><p>Once the likelihood is computed, <a href="#AdmissionsSimulation.matriculation_probability-Tuple{Any, Any}"><code>matriculation_probability</code></a> estimates the probability that the given applicant will accept an offer. <a href="#AdmissionsSimulation.select_applicant-Tuple{Any, Any}"><code>select_applicant</code></a> allows you to randomly sample these by likelihood, and may serve as the basis for running simulations about outcomes, although <a href="#AdmissionsSimulation.run_simulation"><code>run_simulation</code></a> (which just uses matriculation probability) may be a more useful approach.</p><h2 id="API-reference"><a class="docs-heading-anchor" href="#API-reference">API reference</a><a id="API-reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-reference" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="AdmissionsSimulation.FacultyRecord" href="#AdmissionsSimulation.FacultyRecord"><code>AdmissionsSimulation.FacultyRecord</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>FacultyRecord</code> stores the program affiliations and service contributions of a particular faculty member.</p><ul><li><p><code>start::Dates.Date</code></p><p>Date on which the faculty member was approved to train students in any program</p></li></ul><ul><li><p><code>programs::Vector{String}</code></p><p>Program affiliations, in decreasing order of importance (e.g., primary, secondary, ...)</p></li></ul><ul><li><p><code>service::Vector{Pair{String, Service}}</code></p><p><code>program=&gt;Service</code> contributions (to any program, not just those listed in <code>programs</code>)</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/AdmissionsSimulation.jl/blob/e5117c55c963f2f68c14d459f7a9881eeda73899/src/types.jl#L237-L241">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdmissionsSimulation.NormalizedApplicant" href="#AdmissionsSimulation.NormalizedApplicant"><code>AdmissionsSimulation.NormalizedApplicant</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>NormalizedApplicant</code> holds normalized data about an applicant who received, or may receive, an offer of admission.</p><ul><li><p><code>program::String</code></p><p>The abbreviation of the program the applicant was admitted to. <code>AdmissionsSimulation.program_lookups</code> contains the list of valid choices, together with their full names.</p></li></ul><ul><li><p><code>season::Int16</code></p><p>The year in which the applicant&#39;s decision was due. E.g., if the last date was April 15th, 2021, this would be 2021.</p></li></ul><ul><li><p><code>normrank::Union{Missing, Float32}</code></p><p>Normalized rank of the applicant: the top applicant has a rank near 0 (e.g., 1/302), and the bottom applicant has rank 1. The rank is computed among all applicants, not just those who received an offer of admission.</p></li></ul><ul><li><p><code>normofferdate::Float32</code></p><p>Normalized date at which the applicant received the offer of admission. 0 = date of first offer of season, 1 = decision date (typically April 15th). Candidates who were admitted in the first round would have a value of 0 (or near it), whereas candidates who were on the wait list and eventually received offers would have a larger value for this parameter.</p></li></ul><ul><li><p><code>normdecidedate::Union{Missing, Float32}</code></p><p>Normalized date at which the applicant replied with a decision. This uses the same scale as <code>normofferdate</code>. Consequently, an applicant who decided almost immediately would have a <code>normdecidedate</code> shortly after the <code>normofferdate</code>, whereas a candidate who decided on the final day will have a value of 1.0.</p><p>Use <code>missing</code> if the applicant has not yet decided.</p></li></ul><ul><li><p><code>accept::Union{Missing, Bool}</code></p><p><code>true</code> if the applicant accepted our offer, <code>false</code> if not. Use <code>missing</code> if the applicant has not yet decided.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/AdmissionsSimulation.jl/blob/e5117c55c963f2f68c14d459f7a9881eeda73899/src/types.jl#L71-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdmissionsSimulation.NormalizedApplicant-Tuple{}" href="#AdmissionsSimulation.NormalizedApplicant-Tuple{}"><code>AdmissionsSimulation.NormalizedApplicant</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">normapp = NormalizedApplicant(; program, rank=missing, offerdate, decidedate=missing, accept=missing, program_history)</code></pre><p>Create an applicant from &quot;natural&quot; units, where rank is an integer and dates are expressed in <code>Date</code> format. Some are required (those without a default value), others are optional:</p><ul><li><code>program</code>: a string encoding the program</li><li><code>rank::Int</code>: the rank of the applicant compared to other applicants to the same program in the same season.  Use 1 for the top candidate; the bottom candidate should have rank equal to the number of applications received.</li><li><code>offerdate</code>: the date on which an offer was (or might be) extended. E.g., <code>Date(&quot;2021-01-13&quot;)</code>.</li><li><code>decidedate</code>: the date on which the candidate replied with a verdict, or <code>missing</code></li><li><code>accept</code>: <code>true</code> if the candidate accepted our offer, <code>false</code> if it was turned down, <code>missing</code> if it is unknown.</li></ul><p><code>program_history</code> should be a dictionary mapping <a href="#AdmissionsSimulation.ProgramKey"><code>ProgramKey</code></a>s to <a href="#AdmissionsSimulation.ProgramData"><code>ProgramData</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/AdmissionsSimulation.jl/blob/e5117c55c963f2f68c14d459f7a9881eeda73899/src/types.jl#L116-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdmissionsSimulation.Outcome" href="#AdmissionsSimulation.Outcome"><code>AdmissionsSimulation.Outcome</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Outcome(ndeclines, naccepts)</code></pre><p>Tally of the number of declines and accepts for offers of admission.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/AdmissionsSimulation.jl/blob/e5117c55c963f2f68c14d459f7a9881eeda73899/src/types.jl#L156-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdmissionsSimulation.ProgramData" href="#AdmissionsSimulation.ProgramData"><code>AdmissionsSimulation.ProgramData</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>ProgramData</code> stores summary data for a particular program and admissions season.</p><ul><li><p><code>target_raw::Int64</code></p><p>The target number of matriculants, based on applicant pool and training capacity.</p></li></ul><ul><li><p><code>target_corrected::Int64</code></p><p>The actual target, correcting for over- or under-recruitment in previous years.</p></li></ul><ul><li><p><code>nmatriculants::Union{Missing, Int64}</code></p><p>The number of matriculated students, or <code>missing</code>.</p></li></ul><ul><li><p><code>napplicants::Int64</code></p><p>The number of applicants received.</p></li></ul><ul><li><p><code>firstofferdate::Dates.Date</code></p><p>The date on which the first offer was made, essentially the beginning of the decision period for the applicants.</p></li></ul><ul><li><p><code>lastdecisiondate::Dates.Date</code></p><p>The date on which all applicants must have rendered a decision, or the offer expires.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/AdmissionsSimulation.jl/blob/e5117c55c963f2f68c14d459f7a9881eeda73899/src/types.jl#L27-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdmissionsSimulation.ProgramKey" href="#AdmissionsSimulation.ProgramKey"><code>AdmissionsSimulation.ProgramKey</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>ProgramKey</code> stores the program name and admissions season.</p><ul><li><p><code>program::String</code></p><p>The program abbreviation. <code>AdmissionsSimulation.program_lookups</code> contains the list of valid choices, together will full names.</p></li></ul><ul><li><p><code>season::Int16</code></p><p>The enrollment year. This is the year in which the applicant&#39;s decision was due. E.g., if the last date was April 15th, 2021, this would be 2021.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/AdmissionsSimulation.jl/blob/e5117c55c963f2f68c14d459f7a9881eeda73899/src/types.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdmissionsSimulation.ProgramYieldPrediction" href="#AdmissionsSimulation.ProgramYieldPrediction"><code>AdmissionsSimulation.ProgramYieldPrediction</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>ProgramYieldPrediction</code> records mid-season predictions and data for a particular program.</p><ul><li><p><code>nmatriculants::Measurements.Measurement{Float32}</code></p><p>The predicted number of matriculants.</p></li></ul><ul><li><p><code>priority::Float32</code></p><p>The program&#39;s priority for receiving wait list offers. The program with the highest priority should get the next offer. Priority is computed as <code>deficit/stddev</code>, where <code>deficit</code> is the predicted undershoot (which might be negative if the program is predicted to overshoot) and <code>stddev</code> is the square root of the target (Poisson noise). Thus, programs are prioritized by the significance of the deficit.</p></li></ul><ul><li><p><code>poutcome::Union{Missing, Float32}</code></p><p>The two-tailed p-value of the actual outcome (if supplied). This includes the effects of any future wait-list offers.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/AdmissionsSimulation.jl/blob/e5117c55c963f2f68c14d459f7a9881eeda73899/src/types.jl#L171-L175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdmissionsSimulation.Service" href="#AdmissionsSimulation.Service"><code>AdmissionsSimulation.Service</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>Service</code> measures the service contributions of a particular faculty member to a particular program.</p><ul><li><p><code>ninterviews::Int64</code></p><p>The number of admissions interviews conducted for that program, typically over a fixed time window.</p></li></ul><ul><li><p><code>ncommittees::Int64</code></p><p>The number of thesis committees served on for that program, typically over a fixed time window.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/AdmissionsSimulation.jl/blob/e5117c55c963f2f68c14d459f7a9881eeda73899/src/types.jl#L199-L203">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdmissionsSimulation.ServiceCalibration" href="#AdmissionsSimulation.ServiceCalibration"><code>AdmissionsSimulation.ServiceCalibration</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>ServiceCalibration</code> is meant to standardize forms of service to account for the fact that young programs may not have students in thesis committees and therefore don&#39;t have as much service per faculty member.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/AdmissionsSimulation.jl/blob/e5117c55c963f2f68c14d459f7a9881eeda73899/src/types.jl#L220-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdmissionsSimulation.aggregate-Tuple{Union{AbstractDict{ProgramKey, ProgramData}, AbstractVector{Pair{ProgramKey, ProgramData}}}, Any}" href="#AdmissionsSimulation.aggregate-Tuple{Union{AbstractDict{ProgramKey, ProgramData}, AbstractVector{Pair{ProgramKey, ProgramData}}}, Any}"><code>AdmissionsSimulation.aggregate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">proghist = aggregate(program_history::ListPairs{ProgramKey, ProgramData}, mergepairs)</code></pre><p>Aggregate program history, merging program <code>from =&gt; to</code> pairs from <code>mergepairs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/AdmissionsSimulation.jl/blob/e5117c55c963f2f68c14d459f7a9881eeda73899/src/utils.jl#L111-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdmissionsSimulation.aggregate-Tuple{Union{AbstractDict{String, FacultyRecord}, AbstractVector{Pair{String, FacultyRecord}}}, Any}" href="#AdmissionsSimulation.aggregate-Tuple{Union{AbstractDict{String, FacultyRecord}, AbstractVector{Pair{String, FacultyRecord}}}, Any}"><code>AdmissionsSimulation.aggregate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">facrecsnew = aggregate(facrecs::ListPairs{String,FacultyRecord}, mergepairs)</code></pre><p>Aggregate faculty records, merging program <code>from =&gt; to</code> pairs from <code>mergepairs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/AdmissionsSimulation.jl/blob/e5117c55c963f2f68c14d459f7a9881eeda73899/src/utils.jl#L145-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdmissionsSimulation.cached_similarity-Tuple{Any, Any}" href="#AdmissionsSimulation.cached_similarity-Tuple{Any, Any}"><code>AdmissionsSimulation.cached_similarity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fsim = cached_similarity(σsel, σyield; offerdata, yielddata)</code></pre><p>Cache the result of <a href="#AdmissionsSimulation.program_similarity-Tuple{AbstractString, AbstractString}"><code>program_similarity</code></a>, creating a function <code>fsim(program1::AbstractString, program2::AbstractString)</code> to compute the similarity between <code>program1</code> and <code>program2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/AdmissionsSimulation.jl/blob/e5117c55c963f2f68c14d459f7a9881eeda73899/src/similarity.jl#L125-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdmissionsSimulation.calibrate_service" href="#AdmissionsSimulation.calibrate_service"><code>AdmissionsSimulation.calibrate_service</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sc = calibrate_service(progsvc, yrthresh = &lt;7 years ago today&gt;)</code></pre><p>Calculate an equivalence between different forms of service. This is to handle the fact that young programs don&#39;t provide opportunities for service in the form of thesis commmittees. <code>progsvc</code> is from <a href="@ref"><code>program-service</code></a>, and <code>yrthresh</code> selects &quot;old&quot; programs (ones that existed prior to <code>yrthresh</code>) useful for calibration.</p><p><code>sc</code> allows a calculation of total service based on the maximum score computed from interviews or from committees.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/AdmissionsSimulation.jl/blob/e5117c55c963f2f68c14d459f7a9881eeda73899/src/targets.jl#L77-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdmissionsSimulation.faculty_affiliations" href="#AdmissionsSimulation.faculty_affiliations"><code>AdmissionsSimulation.faculty_affiliations</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">naffil = faculty_affiliations(facrecs, scheme)</code></pre><p>Compute the number of affiliations per program. <code>facrecs</code> is a list of <code>facultyname::String =&gt; facrec::FacultyRecord</code> pairs containing details about the affiliations of each faculty member (see <a href="#AdmissionsSimulation.FacultyRecord"><code>FacultyRecord</code></a>). <code>facrecs</code> can be read via <a href="#AdmissionsSimulation.read_faculty_data-Tuple{AbstractString, Vararg{Any, N} where N}"><code>read_faculty_data</code></a>.</p><p><code>scheme</code> controls the weighting of affiliations for faculty members with more than one affiliation:</p><ul><li><code>:primary</code>: count only the faculty member&#39;s primary affiliation (one vote/faculty)</li><li><code>:all</code>: count all affiliations (multiple votes/faculty depending on the number of affiliations)</li><li><code>:normalized</code>: one vote per faculty, spread equally among all that faculty member&#39;s affiliations</li><li><code>:weighted</code>: one vote per faculty, with decreasing weight. For a faculty member with 3 affiliations, they would be assigned a ratio of 3 to 2 to 1.  Hence the primary program would get 3/6=0.5, secondary 2/6=0.33, and tertiary 1/6=0.17.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/AdmissionsSimulation.jl/blob/e5117c55c963f2f68c14d459f7a9881eeda73899/src/targets.jl#L3-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdmissionsSimulation.faculty_effort-Tuple{Union{AbstractDict{String, FacultyRecord}, AbstractVector{Pair{String, FacultyRecord}}}, AbstractRange{var&quot;#s30&quot;} where var&quot;#s30&quot;&lt;:Union{Dates.Date, Integer}}" href="#AdmissionsSimulation.faculty_effort-Tuple{Union{AbstractDict{String, FacultyRecord}, AbstractVector{Pair{String, FacultyRecord}}}, AbstractRange{var&quot;#s30&quot;} where var&quot;#s30&quot;&lt;:Union{Dates.Date, Integer}}"><code>AdmissionsSimulation.faculty_effort</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">faculty, programs, E = faculty_effort(facrecs, daterange::AbstractRange; sc=nothing, progrange=&lt;default&gt;)</code></pre><p>Use <code>facrecs</code>, a list of <code>facultyname::String =&gt; facrec::FacultyRecord</code> pairs, to estimate the average annual effort (in hours) contributed in the forms of service tracked in <a href="#AdmissionsSimulation.Service"><code>Service</code></a>. See <a href="#AdmissionsSimulation.FacultyRecord"><code>FacultyRecord</code></a> and <a href="#AdmissionsSimulation.read_faculty_data-Tuple{AbstractString, Vararg{Any, N} where N}"><code>read_faculty_data</code></a>. <code>daterange</code> specifies the time span covered by <code>facrecs</code>; it could be a <code>Date</code> range or something like <code>2016:2020</code> to indicate a span in calendar years. The optional <code>sc</code> allows you to supply a service calibration, see <a href="#AdmissionsSimulation.calibrate_service"><code>calibrate_service</code></a>. <code>progyears</code> lets you supply a <code>Dict(progname =&gt; yearrange)</code> specifying the duration of existence of each program; the default effectively assumes you&#39;ve called <a href="#AdmissionsSimulation.aggregate-Tuple{Union{AbstractDict{ProgramKey, ProgramData}, AbstractVector{Pair{ProgramKey, ProgramData}}}, Any}"><code>aggregate</code></a> on <code>facrecs</code> to consolidate defunct programs into their modern equivalents.</p><p>On output, <code>E</code> is a <code>length(faculty)</code>-by-<code>length(programs)</code> matrix, where <code>E[j,i]</code> measures the average annual effort committed by faculty member <code>faculty[j]</code> to <code>programs[i]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/AdmissionsSimulation.jl/blob/e5117c55c963f2f68c14d459f7a9881eeda73899/src/targets.jl#L106-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdmissionsSimulation.faculty_involvement-Tuple{AbstractMatrix{T} where T}" href="#AdmissionsSimulation.faculty_involvement-Tuple{AbstractMatrix{T} where T}"><code>AdmissionsSimulation.faculty_involvement</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">f = faculty_involvement(E::AbstractMatrix; scheme=:normeffort, annualthresh=2, M=size(E,1))</code></pre><p>Compute the effective number of faculty <code>f[i]</code> involved in program <code>i</code>, based on annual effort <code>E</code> as computed by <a href="#AdmissionsSimulation.faculty_effort-Tuple{Union{AbstractDict{String, FacultyRecord}, AbstractVector{Pair{String, FacultyRecord}}}, AbstractRange{var&quot;#s30&quot;} where var&quot;#s30&quot;&lt;:Union{Dates.Date, Integer}}"><code>faculty_effort</code></a>. <code>annualthresh</code> is the number of hours that must be exceeded in order to qualify as a contributing faculty member.</p><p>There are three schemes available:</p><ul><li><code>:thresheffort</code>: <code>f[i]</code> gets a +1 contribution from faculty member <code>j</code> if <code>j</code> exceeded <code>annualthresh</code> in that program. (This allows one faculty member to count multiple times.)</li><li><code>:normeffort</code> (the default): for each faculty member who&#39;s total service hours across all programs exceeds <code>annualthresh</code>, distribute a total of one vote in proportion to service per program.</li><li><code>:effortshare</code>: calculate the average service per faculty member (<code>M</code> faculty members total) for each program. If a faculty member exceeded this threshold for <code>k</code> programs, add <code>1/k</code> to each. <code>annualthresh</code> plays no role here.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/AdmissionsSimulation.jl/blob/e5117c55c963f2f68c14d459f7a9881eeda73899/src/targets.jl#L154-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdmissionsSimulation.match_correlation-NTuple{4, AbstractVector{T} where T}" href="#AdmissionsSimulation.match_correlation-NTuple{4, AbstractVector{T} where T}"><code>AdmissionsSimulation.match_correlation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">match_correlation(σsels::AbstractVector, σyields::AbstractVector, σrs::AbstractVector, σts::AbstractVector;
                  applicants, program_history, kwargs...)</code></pre><p>Compute the prediction accuracy using historical data. For each year in <code>program_history</code> other than the earliest, use prior data to predict the probability of matriculation for each applicant.</p><p>The <code>σ</code> lists contain the values that will be used to compute accuracy; the return value is a 4-dimensional array evaluating the correlation between estimated matriculation probability and acceptance for all possible combinations of these parameters. <code>σsel</code> and <code>σyield</code> will be used by <a href="#AdmissionsSimulation.cached_similarity-Tuple{Any, Any}"><code>cached_similarity</code></a> to determine program similarity; <code>σr</code> and <code>σs</code> will be used to measure applicant similarity.</p><p>Tuning essentially corresponds to picking the index of the entry of the return value and then setting each parameter accordingly:</p><pre><code class="language-julia">corarray = match_correlation(σsels, σyields, σrs, σts; applicants, program_history)
idx = argmax(corarray)
σsel, σyield, σr, σt = σsels[idx[1]], σyields[idx[2]], σrs[idx[3]], σts[idx[4]]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/AdmissionsSimulation.jl/blob/e5117c55c963f2f68c14d459f7a9881eeda73899/src/predict.jl#L161-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdmissionsSimulation.match_correlation-NTuple{4, Real}" href="#AdmissionsSimulation.match_correlation-NTuple{4, Real}"><code>AdmissionsSimulation.match_correlation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">match_correlation(σsel::Real, σyield::Real, σr::Real, σt::Real;
                  applicants, past_applicants, offerdata, yielddata,
                  ptail=0.0f0, minfrac=0.0)</code></pre><p>Compute the correlation between estimated matriculation probability and decline/accept for a list of <code>applicants</code>&#39; matriculation decisions. This function is used to evaluate the accuracy of predictions made by specific model parameters.</p><p>The <code>σ</code> arguments are matching parameters, see <a href="#AdmissionsSimulation.program_similarity-Tuple{AbstractString, AbstractString}"><code>program_similarity</code></a> and <a href="#AdmissionsSimulation.match_function-Tuple{}"><code>match_function</code></a>. <a href="#AdmissionsSimulation.offerdata-Tuple{Any, Any}"><code>offerdata</code></a> and <a href="#AdmissionsSimulation.yielddata-Union{Tuple{Y}, Tuple{Type{Y}, Any}} where Y&lt;:Union{Outcome, Tuple{Outcome, Vararg{Outcome, N} where N}}"><code>yielddata</code></a> are computed by functions of the same name. <code>ptail</code> is used to clamp the estimated matriculation probability between bounds, <code>clamp(pmatric, ptail, 1-ptail)</code>. <code>minfrac</code> expresses the minimum fraction of <code>past_applicants</code> allowed to be matched; any <code>test_applicant</code> matching fewer than these (in the sense of the sum of likelihoods computed by <a href="#AdmissionsSimulation.match_likelihood-Tuple{Function, AbstractVector{NormalizedApplicant}, NormalizedApplicant, Dates.Date}"><code>match_likelihood</code></a>) leads to a return value of <code>NaN</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/AdmissionsSimulation.jl/blob/e5117c55c963f2f68c14d459f7a9881eeda73899/src/predict.jl#L137-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdmissionsSimulation.match_function-Tuple{}" href="#AdmissionsSimulation.match_function-Tuple{}"><code>AdmissionsSimulation.match_function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fmatch = match_function(; σr=Inf32, σt=Inf32, progsim=default_similarity)</code></pre><p>Generate a matching function comparing two applicants.</p><pre><code class="language-none">fmatch(template::NormalizedApplicant, applicant::NormalizedApplicant, tnow::Union{Real,Missing})</code></pre><p>will return a number between 0 and 1, with 1 indicating a perfect match. <code>template</code> is the applicant you wish to find a match for, and <code>applicant</code> is a candidate match. <code>tnow</code> is used to exclude <code>applicant</code>s who had already decided by <code>tnow</code>.</p><p>The parameters of <code>fmatch</code> are determined by <code>criteria</code>:</p><ul><li><code>σr</code>: the standard deviation of <code>normrank</code> (use <code>Inf</code> or <code>missing</code> if you don&#39;t want to consider rank in matches)</li><li><code>σt</code>: the standard deviation of <code>normofferdate</code> (use <code>Inf</code> or <code>missing</code> if you don&#39;t want to consider offer date in matches)</li><li><code>progsim</code>: a function <code>progsim(program1, program2)</code> computing the &quot;similarity&quot; between programs. See <a href="#AdmissionsSimulation.cached_similarity-Tuple{Any, Any}"><code>cached_similarity</code></a>. The default returns <code>true</code> if <code>program1 == program2</code> and <code>false</code> otherwise.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/AdmissionsSimulation.jl/blob/e5117c55c963f2f68c14d459f7a9881eeda73899/src/similarity.jl#L182-L199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdmissionsSimulation.match_likelihood-Tuple{Function, AbstractVector{NormalizedApplicant}, NormalizedApplicant, Dates.Date}" href="#AdmissionsSimulation.match_likelihood-Tuple{Function, AbstractVector{NormalizedApplicant}, NormalizedApplicant, Dates.Date}"><code>AdmissionsSimulation.match_likelihood</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">likelihood = match_likelihood(fmatch, past_applicants, applicant, tnow::Date; program_history)</code></pre><p>Use this format if supplying <code>tnow</code> in <code>Date</code> format.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/AdmissionsSimulation.jl/blob/e5117c55c963f2f68c14d459f7a9881eeda73899/src/similarity.jl#L168-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdmissionsSimulation.match_likelihood-Tuple{Function, AbstractVector{NormalizedApplicant}, NormalizedApplicant, Real}" href="#AdmissionsSimulation.match_likelihood-Tuple{Function, AbstractVector{NormalizedApplicant}, NormalizedApplicant, Real}"><code>AdmissionsSimulation.match_likelihood</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">likelihood = match_likelihood(fmatch::Function,
                              past_applicants::AbstractVector{NormalizedApplicant},
                              applicant::NormalizedApplicant,
                              tnow::Real)</code></pre><p>Compute the likelihood among <code>past_applicants</code> for matching <code>applicant</code>. <code>tnow</code> is the current date in normalized form (see <a href="#AdmissionsSimulation.normdate-Tuple{Dates.Date, ProgramData}"><code>normdate</code></a>), and is used to exclude previous applicants who had already made a decision by <code>tnow</code>.</p><p>See also: <a href="#AdmissionsSimulation.match_function-Tuple{}"><code>match_function</code></a>, <a href="#AdmissionsSimulation.select_applicant-Tuple{Any, Any}"><code>select_applicant</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/AdmissionsSimulation.jl/blob/e5117c55c963f2f68c14d459f7a9881eeda73899/src/similarity.jl#L149-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdmissionsSimulation.matriculation_probability-Tuple{Any, Any}" href="#AdmissionsSimulation.matriculation_probability-Tuple{Any, Any}"><code>AdmissionsSimulation.matriculation_probability</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">p = matriculation_probability(likelihood, past_applicants)</code></pre><p>Compute the probability that applicants weighted by <code>likelihood</code> would matriculate into the program, based on the choices made by <code>past_applicants</code>.</p><p><code>likelihood</code> can be computed by <a href="#AdmissionsSimulation.match_likelihood-Tuple{Function, AbstractVector{NormalizedApplicant}, NormalizedApplicant, Dates.Date}"><code>match_likelihood</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/AdmissionsSimulation.jl/blob/e5117c55c963f2f68c14d459f7a9881eeda73899/src/predict.jl#L4-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdmissionsSimulation.normdate-Tuple{Dates.Date, ProgramData}" href="#AdmissionsSimulation.normdate-Tuple{Dates.Date, ProgramData}"><code>AdmissionsSimulation.normdate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">normdate(t::Date, pdata::ProgramData)</code></pre><p>Express <code>t</code> as a fraction of the gap between the first offer date and last decision date as stored in <code>pdata</code> (see <a href="#AdmissionsSimulation.ProgramData"><code>ProgramData</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/AdmissionsSimulation.jl/blob/e5117c55c963f2f68c14d459f7a9881eeda73899/src/utils.jl#L84-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdmissionsSimulation.offerdata-Tuple{Any, Any}" href="#AdmissionsSimulation.offerdata-Tuple{Any, Any}"><code>AdmissionsSimulation.offerdata</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">offerdata(applicants, program_history)</code></pre><p>Summarize application and offer data for each program. The output is a dictionary mapping <code>programname =&gt; (noffers, napplicants)</code>. The program selectivity is the ratio <code>noffers/napplicants</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/AdmissionsSimulation.jl/blob/e5117c55c963f2f68c14d459f7a9881eeda73899/src/similarity.jl#L23-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdmissionsSimulation.program_service-Tuple{Union{AbstractDict{String, FacultyRecord}, AbstractVector{Pair{String, FacultyRecord}}}}" href="#AdmissionsSimulation.program_service-Tuple{Union{AbstractDict{String, FacultyRecord}, AbstractVector{Pair{String, FacultyRecord}}}}"><code>AdmissionsSimulation.program_service</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">progsvc = program_service(facrecs)</code></pre><p>Compute the total service for each program. <code>progsvc</code> is a <code>Dict(progname =&gt; ::Service)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/AdmissionsSimulation.jl/blob/e5117c55c963f2f68c14d459f7a9881eeda73899/src/targets.jl#L62-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdmissionsSimulation.program_similarity-Tuple{AbstractString, AbstractString}" href="#AdmissionsSimulation.program_similarity-Tuple{AbstractString, AbstractString}"><code>AdmissionsSimulation.program_similarity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">program_similarity(program1::AbstractString, program2::AbstractString;
                   σsel=Inf32, σyield=Inf32, offerdata, yielddata)</code></pre><p>Compute the similarity between <code>program1</code> and <code>program2</code>, based on selectivity (fraction of applicants who are admitted) and yield (fraction of offers that get accepted). The similarity ranges between 0 and 1, with 1 corresponding to identical programs.</p><p>The keyword arguments are the parameters controlling the similarity computation. <code>offerdata</code> and <code>yielddata</code> are the outputs of two functions of the same name (<a href="#AdmissionsSimulation.offerdata-Tuple{Any, Any}"><code>offerdata</code></a> and <a href="#AdmissionsSimulation.yielddata-Union{Tuple{Y}, Tuple{Type{Y}, Any}} where Y&lt;:Union{Outcome, Tuple{Outcome, Vararg{Outcome, N} where N}}"><code>yielddata</code></a>). <code>σsel</code> and <code>σyield</code> are the standard deviations of selectivity and yield. The similarity is computed as</p><p class="math-container">\[\exp\left(-\frac{(s₁ - s₂)²}{2σ_\text{sel}²} - \frac{(y₁ - y₂)²}{2σ_\text{yield}²}\right).\]</p><p>The output of this function can be cached with <a href="#AdmissionsSimulation.cached_similarity-Tuple{Any, Any}"><code>cached_similarity</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/AdmissionsSimulation.jl/blob/e5117c55c963f2f68c14d459f7a9881eeda73899/src/similarity.jl#L82-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdmissionsSimulation.read_applicant_data-Tuple{AbstractString}" href="#AdmissionsSimulation.read_applicant_data-Tuple{AbstractString}"><code>AdmissionsSimulation.read_applicant_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">past_applicants = read_applicant_data(filename; program_history)</code></pre><p>Read past applicant data from a file. See &quot;/home/runner/work/AdmissionsSimulation.jl/AdmissionsSimulation.jl/src/test/data/applicantdata.csv&quot; for an example of the format.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/AdmissionsSimulation.jl/blob/e5117c55c963f2f68c14d459f7a9881eeda73899/src/io.jl#L27-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdmissionsSimulation.read_faculty_data-Tuple{AbstractString, Vararg{Any, N} where N}" href="#AdmissionsSimulation.read_faculty_data-Tuple{AbstractString, Vararg{Any, N} where N}"><code>AdmissionsSimulation.read_faculty_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">facrecs = read_faculty_data(filename)</code></pre><p>Read faculty training participation from a file. See &quot;/home/runner/work/AdmissionsSimulation.jl/AdmissionsSimulation.jl/src/test/data/facultyinvolvement.csv&quot; for an example of the format.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/AdmissionsSimulation.jl/blob/e5117c55c963f2f68c14d459f7a9881eeda73899/src/io.jl#L43-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdmissionsSimulation.read_program_history-Tuple{AbstractString}" href="#AdmissionsSimulation.read_program_history-Tuple{AbstractString}"><code>AdmissionsSimulation.read_program_history</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">program_history = read_program_history(filename)</code></pre><p>Read program history from a file. See &quot;/home/runner/work/AdmissionsSimulation.jl/AdmissionsSimulation.jl/src/test/data/programdata.csv&quot; for an example of the format.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/AdmissionsSimulation.jl/blob/e5117c55c963f2f68c14d459f7a9881eeda73899/src/io.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdmissionsSimulation.run_simulation" href="#AdmissionsSimulation.run_simulation"><code>AdmissionsSimulation.run_simulation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nmatriculants = run_simulation(pmatrics::AbstractVector, nsim::Int=100)</code></pre><p>Given a list of candidates each with probability of matriculation <code>pmatrics[i]</code>, perform <code>nsim</code> simulations of their admission decisions and compute the total number of matriculants in each simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/AdmissionsSimulation.jl/blob/e5117c55c963f2f68c14d459f7a9881eeda73899/src/predict.jl#L39-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdmissionsSimulation.select_applicant-Tuple{Any, Any}" href="#AdmissionsSimulation.select_applicant-Tuple{Any, Any}"><code>AdmissionsSimulation.select_applicant</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">past_applicant = select_applicant(clikelihood, past_applicants)</code></pre><p>Select a previous applicant from among <code>past_applicants</code>, using the cumulative likelihood <code>clikelihood</code>. This can be computed as <code>cumsum(likelihood)</code>, where <code>likelihood</code> is computed by <a href="#AdmissionsSimulation.match_likelihood-Tuple{Function, AbstractVector{NormalizedApplicant}, NormalizedApplicant, Dates.Date}"><code>match_likelihood</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/AdmissionsSimulation.jl/blob/e5117c55c963f2f68c14d459f7a9881eeda73899/src/predict.jl#L27-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdmissionsSimulation.targets-Tuple{Any, Any, Any}" href="#AdmissionsSimulation.targets-Tuple{Any, Any, Any}"><code>AdmissionsSimulation.targets</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">targets(program_applicants, fiis, N)</code></pre><p>Compute the target number of matriculants for each program. <code>program_applicants</code> is a collection of <code>program =&gt; napplicants</code> pairs; <code>fiis</code> is a collection of <code>program =&gt; FII</code> scores (see <a href="#AdmissionsSimulation.faculty_involvement-Tuple{AbstractMatrix{T} where T}"><code>faculty_involvement</code></a>). <code>N</code> is the total number of matriculants across all programs.</p><p>Each program gets weighted by the geometric mean of the # of applicants and FII.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/AdmissionsSimulation.jl/blob/e5117c55c963f2f68c14d459f7a9881eeda73899/src/targets.jl#L185-L193">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdmissionsSimulation.wait_list_analysis-Tuple{Function, AbstractVector{NormalizedApplicant}, AbstractVector{NormalizedApplicant}, Union{Dates.Date, Real}}" href="#AdmissionsSimulation.wait_list_analysis-Tuple{Function, AbstractVector{NormalizedApplicant}, AbstractVector{NormalizedApplicant}, Union{Dates.Date, Real}}"><code>AdmissionsSimulation.wait_list_analysis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nmatric, progstatus = wait_list_analysis(fmatch::Function,
                                         past_applicants::AbstractVector{NormalizedApplicant},
                                         applicants::AbstractVector{NormalizedApplicant},
                                         tnow::Date;
                                         program_history,
                                         actual_yield=nothing)</code></pre><p>Compute the estimated number <code>nmatric</code> of matriculants and the program-specific yield prediction and wait-list priority, <code>progstatus</code>. <code>progstatus</code> is a mapping <code>progname =&gt; progyp::ProgramYieldPrediction</code> (see <a href="#AdmissionsSimulation.ProgramYieldPrediction"><code>ProgramYieldPrediction</code></a>).</p><p>The arguments are similarly to <a href="#AdmissionsSimulation.match_likelihood-Tuple{Function, AbstractVector{NormalizedApplicant}, NormalizedApplicant, Dates.Date}"><code>match_likelihood</code></a>. If you&#39;re doing a post-hoc analysis, <code>actual_yield</code> can be a <code>Dict(progname =&gt; nmatric)</code>, in which case the p-value for the observed outcome will also be stored in <code>progstatus</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/AdmissionsSimulation.jl/blob/e5117c55c963f2f68c14d459f7a9881eeda73899/src/predict.jl#L59-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdmissionsSimulation.yielddata-Union{Tuple{Y}, Tuple{Type{Y}, Any}} where Y&lt;:Union{Outcome, Tuple{Outcome, Vararg{Outcome, N} where N}}" href="#AdmissionsSimulation.yielddata-Union{Tuple{Y}, Tuple{Type{Y}, Any}} where Y&lt;:Union{Outcome, Tuple{Outcome, Vararg{Outcome, N} where N}}"><code>AdmissionsSimulation.yielddata</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">yielddata(Outcome, applicants)
yielddata(Tuple{Outcome,Outcome,Outcome}, applicants)</code></pre><p>Compute the outcome of offers of admission for each program. <code>applicants</code> should be a list of <a href="#AdmissionsSimulation.NormalizedApplicant"><code>NormalizedApplicant</code></a>. The first form computes the <a href="#AdmissionsSimulation.Outcome"><code>Outcome</code></a> for the entire season, and the second breaks the season up into epochs of equal duration and computes the outcome for each epoch separately. If provided, <a href="#AdmissionsSimulation.program_similarity-Tuple{AbstractString, AbstractString}"><code>program_similarity</code></a> will make use of the time-dependence of the yield.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/AdmissionsSimulation.jl/blob/e5117c55c963f2f68c14d459f7a9881eeda73899/src/similarity.jl#L63-L71">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 19 June 2021 11:27">Saturday 19 June 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
