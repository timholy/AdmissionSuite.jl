var documenterSearchIndex = {"docs":
[{"location":"api/#API-reference:-Admit","page":"API","title":"API reference: Admit","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [Admit]","category":"page"},{"location":"api/#Admit.NormalizedApplicant","page":"API","title":"Admit.NormalizedApplicant","text":"NormalizedApplicant holds normalized data about an applicant who received, or may receive, an offer of admission.\n\napplicantdata::PersonalData\nIndividual data about the applicant, see PersonalData.\n\nprogram::String\nThe abbreviation of the program the applicant was admitted to. Admit.program_lookups contains the list of valid choices, together with their full names.\n\nseason::Int16\nThe year in which the applicant's decision was due. E.g., if the decision deadline was April 15th, 2021, this would be 2021.\n\nnormrank::Union{Missing, Float32}\nNormalized rank of the applicant: the top applicant has a rank near 0 (e.g., 1/302), and the bottom applicant has rank 1. The rank is computed among all applicants, not just those who received an offer of admission.\n\nnormofferdate::Union{Missing, Float32}\nNormalized date at which the applicant received the offer of admission. 0 = date of first offer of season, 1 = decision date (typically April 15th). Candidates who were admitted in the first round would have a value of 0 (or near it), whereas candidates who were on the wait list and eventually received offers would have a larger value for this parameter.\n\nnormdecidedate::Union{Missing, Float32}\nNormalized date at which the applicant replied with a decision. This uses the same scale as normofferdate. Consequently, an applicant who decided almost immediately would have a normdecidedate shortly after the normofferdate, whereas a candidate who decided on the final day will have a value of 1.0.\nUse missing if the applicant has not yet decided.\n\naccept::Union{Missing, Bool}\ntrue if the applicant accepted our offer, false if not. Use missing if the applicant has not yet decided.\n\n\n\n\n\n","category":"type"},{"location":"api/#Admit.NormalizedApplicant-Tuple{}","page":"API","title":"Admit.NormalizedApplicant","text":"normapp = NormalizedApplicant(; program, urmdd=missing, foreign=missing, rank=missing, offerdate, decidedate=missing, accept=missing, program_history)\n\nCreate an applicant from \"natural\" units, where rank is an integer and dates are expressed in Date format. Some are required (those without a default value), others are optional:\n\nprogram: a string encoding the program\nurmdd: true if applicant is a URM, disadvantaged, or disabled\nforeign: true if applicant is not a citizen or permanent resident\nrank::Int: the rank of the applicant compared to other applicants to the same program in the same season.  Use 1 for the top candidate; the bottom candidate should have rank equal to the number of applications received.\nofferdate: the date on which an offer was (or might be) extended. E.g., Date(\"2021-01-13\").\ndecidedate: the date on which the candidate replied with a verdict, or missing\naccept: true if the candidate accepted our offer, false if it was turned down, missing if it is unknown.\n\nprogram_history should be a dictionary mapping ProgramKeys to ProgramData.\n\n\n\n\n\n","category":"method"},{"location":"api/#Admit.Outcome","page":"API","title":"Admit.Outcome","text":"Outcome(ndeclines, naccepts)\n\nTally of the number of declines and accepts for offers of admission.\n\n\n\n\n\n","category":"type"},{"location":"api/#Admit.PersonalData","page":"API","title":"Admit.PersonalData","text":"PersonalData holds relevant data about an individual applicant.\n\nname::String\nName of the applicant\n\nurmdd::Union{Missing, Bool}\ntrue if an applicant is an underrepresented minority, disadvantaged, or disabled.\n\nforeign::Union{Missing, Bool}\ntrue if an applicant is not a US citizen or permanent resident.\n\n\n\n\n\n","category":"type"},{"location":"api/#Admit.ProgramData","page":"API","title":"Admit.ProgramData","text":"ProgramData stores summary data for a particular program and admissions season.\n\ntarget_raw::Int64\nThe target number of matriculants, based on applicant pool and training capacity.\n\ntarget_corrected::Int64\nThe actual target, correcting for over- or under-recruitment in previous years.\n\nnmatriculants::Union{Missing, Int64}\nThe number of matriculated students, or missing.\n\nnapplicants::Int64\nThe number of applicants received.\n\nfirstofferdate::Dates.Date\nThe date on which the first offer was made, essentially the beginning of the decision period for the applicants.\n\nlastdecisiondate::Dates.Date\nThe date on which all applicants must have rendered a decision, or the offer expires.\n\n\n\n\n\n","category":"type"},{"location":"api/#Admit.ProgramKey","page":"API","title":"Admit.ProgramKey","text":"ProgramKey stores the program name and admissions season.\n\nprogram::String\nThe program abbreviation. Admit.program_lookups contains the list of valid choices, together will full names.\n\nseason::Int16\nThe enrollment year. This is the year in which the applicant's decision was due. E.g., if the last date was April 15th, 2021, this would be 2021.\n\n\n\n\n\n","category":"type"},{"location":"api/#Admit.ProgramYieldPrediction","page":"API","title":"Admit.ProgramYieldPrediction","text":"ProgramYieldPrediction records mid-season predictions and data for a particular program.\n\nnmatriculants::Measurements.Measurement{Float32}\nThe predicted number of matriculants.\n\npriority::Float32\nThe program's priority for receiving wait list offers. The program with the highest priority should get the next offer. Priority is computed as deficit/stddev, where deficit is the predicted undershoot (which might be negative if the program is predicted to overshoot) and stddev is the square root of the target (Poisson noise). Thus, programs are prioritized by the significance of the deficit.\n\npoutcome::Union{Missing, Float32}\nThe two-tailed p-value of the actual outcome (if supplied). This includes the effects of any future wait-list offers.\n\n\n\n\n\n","category":"type"},{"location":"api/#Admit.add_offers!","page":"API","title":"Admit.add_offers!","text":"nmatric, pq0=>pq = add_offers!(fmatch, program_offers::Dict, program_candidates::Dict, past_applicants, tnow::Date=today(), σthresh=2; program_history)\n\nTransfer applicants from program_candidates to program_offers depending on whether projections in nmatric are below DBBS-wide target by at least σthresh standard deviations.  nmatric0 is computed upon entrance, while nmatric reflects updated projections after adding offers. Likewise pq0 is the program-priority initially, and pq after adding offers.\n\ntnow should be the date for which the computation should be performed, and is used to determine whether candidates have already informed us of their decision.\n\nPrograms are prioritized for offers by the deficit divided by the expected noise.\n\n\n\n\n\n","category":"function"},{"location":"api/#Admit.aggregate-Tuple{Union{AbstractDict{ProgramKey, ProgramData}, AbstractVector{Pair{ProgramKey, ProgramData}}}, Any}","page":"API","title":"Admit.aggregate","text":"proghist = aggregate(program_history::ListPairs{ProgramKey, ProgramData}, mergepairs)\n\nAggregate program history, merging program from => to pairs from mergepairs.\n\n\n\n\n\n","category":"method"},{"location":"api/#Admit.cached_similarity-Tuple{Any, Any}","page":"API","title":"Admit.cached_similarity","text":"fsim = cached_similarity(σsel, σyield; offerdata, yielddata)\n\nCache the result of program_similarity, creating a function fsim(program1::AbstractString, program2::AbstractString) to compute the similarity between program1 and program2.\n\n\n\n\n\n","category":"method"},{"location":"api/#Admit.extract_program_history","page":"API","title":"Admit.extract_program_history","text":"program_history = extract_program_history(applicants)\nprogram_history = extract_program_history(applicants, program_metadata)\n\nAssemble the necessary program_history from applicants and external program_metadata. applicants is parsed to identify the date of the first offer for each ProgramKey(program, season) combination. The remaining data come from program_metadata, which can be obtained from parse_programs.\n\n\n\n\n\n","category":"function"},{"location":"api/#Admit.generate_fake_candidates","page":"API","title":"Admit.generate_fake_candidates","text":"program_candidates = generate_fake_candidates(program_history, season::Integer, program_offer_dates=nothing)\n\nGenerate fake candidates for each program, each ranked starting from 1. season is the year for which the offers should be generated. Optionally provide program_offer_dates, a program_name=>list_of_offer_dates dictionary which will be used to generate offer dates (by default set to the firstofferdate in program_history). Unless σt is quite small in the matching function, adding additional offer dates (e.g., for multiple interview dates) may not change the outcome substantially.\n\nOn output, program_candidates is a Dict(program1=>[applicant1a, applicant1b, ...], ...) storing the fake applicants per program in rank order. See initial_offers!.\n\nExample\n\nThis calculates the number of initial offers per program:\n\njulia> program_candidates = Admit.generate_fake_candidates(program_history, 2021);\n\njulia> program_offers = initial_offers!(fmatch, program_candidates, past_applicants, Date(\"2021-01-01\"); program_history);\n\njulia> noffers = sort([prog => length(list) for (prog, list) in program_offers]; by=first)\n13-element Vector{Pair{String, Int64}}:\n  \"BBSB\" => 16\n  \"BIDS\" => 9\n    \"CB\" => 13\n   \"CSB\" => 14\n \"DRSCB\" => 14\n  \"EEPB\" => 12\n   \"HSG\" => 9\n   \"IMM\" => 16\n   \"MCB\" => 16\n   \"MGG\" => 18\n  \"MMMP\" => 18\n    \"NS\" => 31\n   \"PMB\" => 14\n\n\n\n\n\n","category":"function"},{"location":"api/#Admit.initial_offers!-Tuple{Function, Dict, Vararg{Any, N} where N}","page":"API","title":"Admit.initial_offers!","text":"program_offers, nmatric = initial_offers!(fmatch, program_candidates::Dict, past_applicants, tnow::Date=today(), σthresh=2; program_history)\n\nAllocate initial offers of admission at the beginning of the season.  See add_offers! for more information. See also generate_fake_candidates to plan offers in cases where some programs want to make their initial offers before other programs have finished interviewing.\n\n\n\n\n\n","category":"method"},{"location":"api/#Admit.keep_final_records-Tuple{Any}","page":"API","title":"Admit.keep_final_records","text":"keep_final_records(apps)\n\nDe-duplicate applicant entries retrieved from the database. For each (season, name) combination, this keeps only the most recently updated entry.\n\nThis requires that you define a when_updated(row) function for your database format, see AdmitConfiguration.set_local_functions.\n\n\n\n\n\n","category":"method"},{"location":"api/#Admit.manage_offers","page":"API","title":"Admit.manage_offers","text":"app = manage_offers(fetch_past_applicants::Function, fetch_applicants::Function, fetch_program_data::Function, tnow::Union{Date,Function}=today;\n                    σthresh::Real=2,\n                    σsel=0.2f0, σyield=1.0f0, σr=0.5f0, σt=Inf32)\n\nCreate a report about the current state of admissions. The report has 3 tabs:\n\n\"Summary\" gives an overview across all programs, along with a list of candidates deemed ready to receive an offer given the target in the entry box at the top right.\n\"Program\" provides a detailed view of a single program selected in the dropdown at the top right, showing candidates who have accepted or rejected the offer of admission, along with a predicted matriculation probability for each undecided applicant.\n\"Internals\" provides information about the model details, currently just the \"Program similarity\" score which expresses the use of cross-program data in predicting matriculation probability.\n\nThe \"Refresh applicants\" button fetches fresh data about the current applicants, and should be used to update projections as decisions get made.\n\nThe input arguments are:\n\nfetch_past_applicants() should return a list of NormalizedApplicants from previous admissions years. These will be used to make predictions about the decisions of current applicants.\nfetch_applicants() should return a list of NormalizedApplicants from the current season. This gets called every time you click \"Refresh applicants\".\nfetch_program_data() should return a Dict{ProgramKey,ProgramData} containing overall statistics about the program over the time covered by the combination of fetch_past_applicants and fetch_applicants.\ntnow can either be a Date or a function returning a Date. The default, the function Dates.today, will update the date every time the page renders. Pass a static date only if you don't want the date updating.\nσthresh determines how conservative the system will be in extending wait-list offers. On the \"Summary\" tab, the \"Total estimate\" will be expressed as mean ± stddev, and mean + σthresh * stddev will be held approximately at the total target. Larger values of σthresh make it less likely that you'll overshoot, and more likely that you'll undershoot. Values in the range of 0-3 seem like plausible choices (default: 2).\nσsel and σyield determine the cross-program similarity (see program_similarity)\nσr and σt determine how much the prediction uses applicant rank and offer date, respectively (see match_function).\n\nTo render the report in a browser, use\n\nAdmit.run_server(app, \"0.0.0.0\", debug=true)\n\n\n\n\n\n","category":"function"},{"location":"api/#Admit.match_correlation-Tuple{Function, Vararg{AbstractVector{T} where T, N} where N}","page":"API","title":"Admit.match_correlation","text":"match_correlation(matchcreator::Function, σlists::AbstractVector...;\n                  applicants, program_history, kwargs...)\n\nCompute the prediction accuracy using historical data. For each year in program_history other than the earliest, use prior data to predict the probability of matriculation for each applicant.\n\nThe σ lists contain the values that will be used to compute accuracy; the return value is an n-dimensional array evaluating the correlation between estimated matriculation probability and acceptance for all possible combinations of these parameters. matchcreator(σ1, σ2...; offerdata, yielddata) should return a similarity-computing function fmatch(template, applicant, tnow) using the specific σs provided.\n\nTuning essentially corresponds to picking the index of the entry of the return value and then setting each parameter accordingly:\n\ncorarray = match_correlation(Admit.fmatch_prog_rank_date, σsels, σyields, σrs, σts; applicants, program_history)\nidx = argmax(corarray)\nσsel, σyield, σr, σt = σsels[idx[1]], σyields[idx[2]], σrs[idx[3]], σts[idx[4]]\n\nfmatch_prog_rank_date is a default and can be omitted if you want to use this function.\n\n\n\n\n\n","category":"method"},{"location":"api/#Admit.match_correlation-Tuple{Function}","page":"API","title":"Admit.match_correlation","text":"match_correlation(fmatch; applicants, past_applicants, ptail=0.0f0, minfrac=0.01)\n\nCompute the correlation between estimated matriculation probability and decline/accept for a list of applicants' matriculation decisions. This function is used to evaluate the accuracy of predictions made by specific model parameters.\n\nfmatch(reference, applicant, tnow) is the similarity-computation function. ptail is used to clamp the estimated matriculation probability between bounds, clamp(pmatric, ptail, 1-ptail). minfrac expresses the minimum fraction of past_applicants allowed to be matched; any test_applicant matching fewer than these (in the sense of the sum of likelihoods computed by match_likelihood) leads to a return value of NaN.\n\n\n\n\n\n","category":"method"},{"location":"api/#Admit.match_function-Tuple{}","page":"API","title":"Admit.match_function","text":"fmatch = match_function(; σr=Inf32, σt=Inf32, progsim=default_similarity)\n\nGenerate a matching function comparing two applicants.\n\nfmatch(template::NormalizedApplicant, applicant::NormalizedApplicant, tnow::Union{Real,Missing})\n\nwill return a number between 0 and 1, with 1 indicating a perfect match. template is the applicant you wish to find a match for, and applicant is a candidate match. tnow is used to exclude applicants who had already decided by tnow.\n\nThe parameters of fmatch are determined by criteria:\n\nσr: the standard deviation of normrank (use Inf or missing if you don't want to consider rank in matches)\nσt: the standard deviation of normofferdate (use Inf or missing if you don't want to consider offer date in matches)\nprogsim: a function progsim(program1, program2) computing the \"similarity\" between programs. See cached_similarity. The default returns true if program1 == program2 and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#Admit.match_likelihood-Tuple{Function, AbstractVector{NormalizedApplicant}, NormalizedApplicant, Dates.Date}","page":"API","title":"Admit.match_likelihood","text":"likelihood = match_likelihood(fmatch, past_applicants, applicant, tnow::Date; program_history)\n\nUse this format if supplying tnow in Date format.\n\n\n\n\n\n","category":"method"},{"location":"api/#Admit.match_likelihood-Union{Tuple{F}, Tuple{F, AbstractVector{NormalizedApplicant}, NormalizedApplicant, Float32}} where F","page":"API","title":"Admit.match_likelihood","text":"likelihood = match_likelihood(fmatch::Function,\n                              past_applicants::AbstractVector{NormalizedApplicant},\n                              applicant::NormalizedApplicant,\n                              tnow::Real)\n\nCompute the likelihood among past_applicants for matching applicant. tnow is the current date in normalized form (see normdate), and is used to exclude previous applicants who had already made a decision by tnow.\n\nSee also: match_function, select_applicant.\n\n\n\n\n\n","category":"method"},{"location":"api/#Admit.matriculation_probability-Tuple{Any, Any}","page":"API","title":"Admit.matriculation_probability","text":"p = matriculation_probability(likelihood, past_applicants)\n\nCompute the probability that applicants weighted by likelihood would matriculate into the program, based on the choices made by past_applicants.\n\nlikelihood can be computed by match_likelihood.\n\n\n\n\n\n","category":"method"},{"location":"api/#Admit.normdate-Tuple{Dates.Date, ProgramData}","page":"API","title":"Admit.normdate","text":"normdate(t::Date, pdata::ProgramData)\n\nExpress t as a fraction of the gap between the first offer date and last decision date as stored in pdata (see ProgramData).\n\nExamples\n\njulia> using Dates\n\njulia> pd = ProgramData(firstofferdate=Date(\"2021-02-11\"), lastdecisiondate=Date(\"2021-04-15\"))\nProgramData(0, 0, missing, -1, Date(\"2021-02-11\"), Date(\"2021-04-15\"))\n\njulia> normdate(Date(\"2021-02-11\"), pd)\n0.0f0\n\njulia> normdate(Date(\"2021-04-15\"), pd)\n1.0f0\n\njulia> normdate(Date(\"2021-03-15\"), pd)\n0.50793654f0\n\njulia> normdate(Date(\"2021-01-01\"), pd)    # dates prior to the first offer date are negatve\n-0.6507937f0\n\n\n\n\n\n","category":"method"},{"location":"api/#Admit.offerdata-Tuple{Any, Any}","page":"API","title":"Admit.offerdata","text":"offerdata(applicants, program_history)\n\nSummarize application and offer data for each program. The output is a dictionary mapping programname => (noffers, napplicants). The program selectivity is the ratio noffers/napplicants.\n\n\n\n\n\n","category":"method"},{"location":"api/#Admit.parse_database-Tuple{Any}","page":"API","title":"Admit.parse_database","text":"applicants, program_history = parse_database(conn)\n\nExtract the applicants and program_history from the database.\n\n\n\n\n\n","category":"method"},{"location":"api/#Admit.parse_programs-Tuple{DataFrames.DataFrame}","page":"API","title":"Admit.parse_programs","text":"program_metadata = parse_programs(programs::DataFrame)\n\nExtract program metadata:\n\ntarget number of matriculants, aka \"slots\"\ntotal number of applicants\ntotal number of matriculants (i.e., number who accepted the offer of admission)\n\n\n\n\n\n","category":"method"},{"location":"api/#Admit.program_similarity-Tuple{AbstractString, AbstractString}","page":"API","title":"Admit.program_similarity","text":"program_similarity(program1::AbstractString, program2::AbstractString;\n                   σsel=Inf32, σyield=Inf32, offerdata, yielddata)\n\nCompute the similarity between program1 and program2, based on selectivity (fraction of applicants who are admitted) and yield (fraction of offers that get accepted). The similarity ranges between 0 and 1, with 1 corresponding to identical programs.\n\nThe keyword arguments are the parameters controlling the similarity computation. offerdata and yielddata are the outputs of two functions of the same name (offerdata and yielddata). σsel and σyield are the standard deviations of selectivity and yield. The similarity is computed as\n\nexpleft(-frac(s₁ - s₂)²2σ_textsel² - frac(y₁ - y₂)²2σ_textyield²right)\n\nThe output of this function can be cached with cached_similarity.\n\n\n\n\n\n","category":"method"},{"location":"api/#Admit.query_applicants-Tuple{Any}","page":"API","title":"Admit.query_applicants","text":"apps = query_applicants(conn; deduplicate=false)\n\nFetch all applicants (past and present) from the database using connection conn. apps is a DataFrame. Configure the SELECT statement using set_sql_queries.\n\nIf your database contains multiple entries for each applicant, set deduplicate=true and see the configuration needed for keep_final_records.\n\n\n\n\n\n","category":"method"},{"location":"api/#Admit.query_programs-Tuple{Any}","page":"API","title":"Admit.query_programs","text":"progdata = query_programs(conn)\n\nFetch program targets and other information from the database using connection conn. progdata is a DataFrame. Configure the SELECT statement using set_sql_queries.\n\nIf your database contains multiple entries for each applicant, set deduplicate=true and see the configuration needed for keep_final_records.\n\n\n\n\n\n","category":"method"},{"location":"api/#Admit.read_applicant_data-Tuple{AbstractString}","page":"API","title":"Admit.read_applicant_data","text":"past_applicants = read_applicant_data(filename; program_history)\n\nRead past applicant data from a file. See \"/home/runner/work/AdmissionSuite.jl/AdmissionSuite.jl/Admit/src/test/data/applicantdata.csv\" for an example of the format.\n\n\n\n\n\n","category":"method"},{"location":"api/#Admit.read_program_history-Tuple{AbstractString}","page":"API","title":"Admit.read_program_history","text":"program_history = read_program_history(filename)\n\nRead program history from a file. See \"/home/runner/work/AdmissionSuite.jl/AdmissionSuite.jl/Admit/src/test/data/programdata.csv\" for an example of the format.\n\n\n\n\n\n","category":"method"},{"location":"api/#Admit.run_simulation","page":"API","title":"Admit.run_simulation","text":"nmatriculants = run_simulation(pmatrics::AbstractVector, nsim::Int=100)\n\nGiven a list of candidates each with probability of matriculation pmatrics[i], perform nsim simulations of their admission decisions and compute the total number of matriculants in each simulation.\n\n\n\n\n\n","category":"function"},{"location":"api/#Admit.select_applicant-Tuple{Any, Any}","page":"API","title":"Admit.select_applicant","text":"past_applicant = select_applicant(clikelihood, past_applicants)\n\nSelect a previous applicant from among past_applicants, using the cumulative likelihood clikelihood. This can be computed as cumsum(likelihood), where likelihood is computed by match_likelihood.\n\n\n\n\n\n","category":"method"},{"location":"api/#Admit.wait_list_analysis-Union{Tuple{F}, Tuple{F, AbstractVector{NormalizedApplicant}, AbstractVector{NormalizedApplicant}, Union{Dates.Date, Real}}} where F","page":"API","title":"Admit.wait_list_analysis","text":"nmatric, progstatus = wait_list_analysis(fmatch::Function,\n                                         past_applicants::AbstractVector{NormalizedApplicant},\n                                         applicants::AbstractVector{NormalizedApplicant},\n                                         tnow::Date;\n                                         program_history,\n                                         actual_yield=nothing)\n\nCompute the estimated number nmatric of matriculants and the program-specific yield prediction and wait-list priority, progstatus. progstatus is a mapping progname => progyp::ProgramYieldPrediction (see ProgramYieldPrediction). nmatric assumes all applicants get offers.\n\nThe arguments are similarly to match_likelihood. If you're doing a post-hoc analysis, actual_yield can be a Dict(progname => nmatric), in which case the p-value for the observed outcome will also be stored in progstatus.\n\n\n\n\n\n","category":"method"},{"location":"api/#Admit.yield_errors-Tuple{Any, Any}","page":"API","title":"Admit.yield_errors","text":"yerrs = yield_errors(σsels, σyields; applicants, program_history)\n\nGiven lists of possible σsel and σyield values, compute the cross-program error in predicted yield. On output, yerrs[i,j] is the yield error when using σsels[i] and σyields[j].\n\nThe yield error is based on predicting each years' yield from prior data.\n\n\n\n\n\n","category":"method"},{"location":"api/#Admit.yielddata-Union{Tuple{Y}, Tuple{Type{Y}, Any}} where Y<:Union{Outcome, Tuple{Outcome, Vararg{Outcome, N} where N}}","page":"API","title":"Admit.yielddata","text":"yielddata(Outcome, applicants)\nyielddata(Tuple{Outcome,Outcome,Outcome}, applicants)\n\nCompute the outcome of offers of admission for each program. applicants should be a list of NormalizedApplicant. The first form computes the Outcome for the entire season, and the second breaks the season up into epochs of equal duration and computes the outcome for each epoch separately. If provided, program_similarity will make use of the time-dependence of the yield.\n\n\n\n\n\n","category":"method"},{"location":"api/#API-reference:-AdmitConfiguration","page":"API","title":"API reference: AdmitConfiguration","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [AdmitConfiguration]","category":"page"},{"location":"api/#AdmitConfiguration.addprogram-Tuple{AbstractString}","page":"API","title":"AdmitConfiguration.addprogram","text":"addprogram(abbrv::AbstractString)\n\nDynamically add a new program with abbreviation abbrv.\n\nThis is primarily used for writing tests; most users should use set_programs instead.\n\n\n\n\n\n","category":"method"},{"location":"api/#AdmitConfiguration.connectdsn","page":"API","title":"AdmitConfiguration.connectdsn","text":"conn = connectdsn()\nconn = connectdsn(dsnname; usepasswd::Bool=false)\n\nConnect to a SQL database specified by a Data Source Name (DSN) dsnname, which by default is the one set by set_dsn.\n\nSet usepasswd=true if you need to authenticate with username/password.\n\n\n\n\n\n","category":"function"},{"location":"api/#AdmitConfiguration.delprogram-Tuple{AbstractString}","page":"API","title":"AdmitConfiguration.delprogram","text":"delprogram(abbrv::AbstractString)\n\nDynamically delete the program with abbreviation abbrv.\n\nThis is primarily used for writing tests; most users should use set_programs instead.\n\n\n\n\n\n","category":"method"},{"location":"api/#AdmitConfiguration.getaccept","page":"API","title":"AdmitConfiguration.getaccept","text":"getaccept(row)\n\nReturn true or false depending on whether the applicant in row (a row of the applicant table) accepted the offer of admission.\n\nExample\n\nSuppose your table has a column called \"Outcome\" which takes values \"Accept\", \"Decline\", \"Reject\", or \"Withdrew\". Then in simplest form you could implement this function as:\n\ngetaccept(row) = row.\"Outcome\" == \"Accept\"\n\nMore sophisticated implementations might check for unexpected values and throw an error if they are encountered.\n\n\n\n\n\n","category":"function"},{"location":"api/#AdmitConfiguration.getdecidedate","page":"API","title":"AdmitConfiguration.getdecidedate","text":"getdecidedate(row)\n\nReturn the date on which the applicant in row  (a row of the applicant table) informed admissions about their decision about whether to accept the offer of admission.\n\nExample\n\nSuppose your table has a column called \"Date of verdict\", in which case implementing this would be as simple as\n\ngetdecidedate(row) = row.\"Date of verdict\"\n\nIn contrast, supposed you have multiple columns, \"Date of accept\", \"Date of decline\", \"Date of withdrawal\", of which only one has an entry.  Then this might be implemented as\n\nfunction getdecidedate(row)\n    if !ismissing(row.\"Date of accept\")\n        return row.\"Date of accept\"\n    elseif !ismissing(row.\"Date of decline\")\n        return row.\"Date of decline\"\n    elseif !ismissing(row.\"Date of withdrawal\")\n        return row.\"Date of withdrawal\"\n    else\n        error(\"expected one of the accept/decline/withdrawal dates to be specified\")\n    end\nend\n\n\n\n\n\n","category":"function"},{"location":"api/#AdmitConfiguration.set_column_configuration-Tuple","page":"API","title":"AdmitConfiguration.set_column_configuration","text":"set_column_configuration(stdname1 => dbcolname1, ...)\n\nConfigure the names of columns dbcolnames in your database so that standard properties can be extracted. The properties that must be configured are:\n\nApplicant table columns:\n\n\"name\": the name of the column that stores the applicant name\n\"app program\": the name of the column that stores the name of the program the applicant is being considered for admission in\n\"offer date\": the name of the column that stores the date at which an offer of admission was extended\n\"app season\" (optional): the name of the column that can be used to extract the application season (e.g., 2022) if an offer date is not available for a candidate\n\nProgram table columns:\n\n\"prog program\": the name of the column that stores the program name\n\"prog season\": the name of the column that can be used to extract the application season (e.g., 2022)\n\"slots\": the name of the column that stores the matriculation target for a program\n\"napplicants\" (optional): the name of the column that stores the number of applications received\n\"nmatriculants\" (optional): the name of the column that stores the number of applicants who accepted the offer of admission\n\nExample\n\nset_column_configuration(\"name\" => \"Applicant Name\", \"app program\" => \"Program\", \"offer date\" => \"Acceptance Offered\")\n\nsets up the names of three columns in your database tables.\n\nSee also: set_local_functions.\n\n\n\n\n\n","category":"method"},{"location":"api/#AdmitConfiguration.set_dsn-Tuple{AbstractString}","page":"API","title":"AdmitConfiguration.set_dsn","text":"set_dsn(name)\n\nConfigure a Data Source name for a SQL database\n\n\n\n\n\n","category":"method"},{"location":"api/#AdmitConfiguration.set_local_functions-Tuple{AbstractString}","page":"API","title":"AdmitConfiguration.set_local_functions","text":"set_local_functions(filename)\n\nConfigure custom functions used in parsing applicant tables. The following functions must be implemented:\n\ngetaccept\ngetdecidedate\n\nThe following are optional and only required for certain functionality:\n\nwhen_updated\n\nCreate these functions and save them to a file somewhere permanent on your system. Then pass the filename to set_local_functions to register this file with AdmissionSuite.\n\nSee also: set_column_configuration.\n\n\n\n\n\n","category":"method"},{"location":"api/#AdmitConfiguration.set_programs","page":"API","title":"AdmitConfiguration.set_programs","text":"set_programs(filename; force=false)\n\nConfigure your local programs, given a CSV file filename of the format in examples/WashU.csv. (You can create such files with a spreadsheet program, exporting the table in \"Comma separated value\" format.) The minimum requirement is the Abbreviation column, which must contain the list of all programs in \"short-form\" name. Use ProgramName if you want a long-form name, especially if you use a SQL database which sometimes uses that name.\n\nSeasonStart, SeasonEnd, MergeTo, and SplitFrom can be used to track changes in your programs over time; this can be relevant because historical data is used to forecast matriculation probability (for Admit.jl) and faculty service (for AdmissionTargets.jl). \"Season\" refers to the year for final acceptance of an offer of admission, e.g., a deadline of April 15, 2013 would be season 2013. SeasonStart should contain the first season in which a program admitted applicants; SeasonEnd should contain the last season (if applicable) in which a program admitted applicants. If a defunct program merged into a newer one, set the MergeTo field as the name of the newer program; if a current program was created from a previous one, set the SplitFrom field. If a newly-created program has no clear heritage, just leave these blank (but no prior historical data will be available).\n\nIf you're re-setting the configuration from an existing one, use force=true.\n\nwarning: Warning\nYou need to load the CSV package (using CSV) for set_programs to be available. See the AdmissionSuite web documentation for more information.\n\n\n\n\n\n","category":"function"},{"location":"api/#AdmitConfiguration.set_sql_queries-Tuple{}","page":"API","title":"AdmitConfiguration.set_sql_queries","text":"set_sql_queries(; applicants = \"SELECT * FROM ...\", programs = \"SELECT * FROM ...\")\n\nConfigure the specific queries needed to obtain the applicants and program targets, respectively. \"...\" needs to be specified for your local institution.\n\n\n\n\n\n","category":"method"},{"location":"api/#AdmitConfiguration.validateprogram-Tuple{AbstractString}","page":"API","title":"AdmitConfiguration.validateprogram","text":"prog = validateprogram(program::AbstractString)\n\nReturn the abbreviation prog from either a valid abbreviation or valid long-form program name program. An error is thrown if the program is not recognized.\n\nSee set_programs to configure your local programs, or addprogram and delprogram to configure them dynamically.\n\n\n\n\n\n","category":"method"},{"location":"api/#AdmitConfiguration.when_updated","page":"API","title":"AdmitConfiguration.when_updated","text":"when_updated(row)\n\nReturn date (or date and time) at which a record row was updated in the database. Required for de-duplicating database entries in Admit.keep_final_records.\n\n\n\n\n\n","category":"function"},{"location":"api/#API-reference:-AdmissionTargets","page":"API","title":"API reference: AdmissionTargets","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [AdmissionTargets]","category":"page"},{"location":"api/#AdmissionTargets.FacultyRecord","page":"API","title":"AdmissionTargets.FacultyRecord","text":"FacultyRecord stores the program affiliations and service contributions of a particular faculty member.\n\nstart::Dates.Date\nDate on which the faculty member was approved to train students in any program\n\nprograms::Vector{String}\nProgram affiliations, in decreasing order of importance (e.g., primary, secondary, ...)\n\nservice::Vector{Pair{String, Service}}\nprogram=>Service contributions (to any program, not just those listed in programs)\n\n\n\n\n\n","category":"type"},{"location":"api/#AdmissionTargets.Service","page":"API","title":"AdmissionTargets.Service","text":"Service measures the service contributions of a particular faculty member to a particular program.\n\nninterviews::Float32\nThe number of admissions interviews conducted for that program, typically over a fixed time window.\n\nncommittees::Float32\nThe number of thesis committees served on for that program, typically over a fixed time window.\n\n\n\n\n\n","category":"type"},{"location":"api/#AdmissionTargets.ServiceCalibration","page":"API","title":"AdmissionTargets.ServiceCalibration","text":"ServiceCalibration is meant to standardize forms of service to account for the fact that young programs may not have students in thesis committees and therefore don't have as much service per faculty member.\n\n\n\n\n\n","category":"type"},{"location":"api/#AdmissionTargets.aggregate-Tuple{Union{AbstractDict{var\"#s8\", FacultyRecord}, AbstractArray{Pair{var\"#s8\", FacultyRecord}, 1}} where var\"#s8\"<:AbstractString, Any}","page":"API","title":"AdmissionTargets.aggregate","text":"facrecsnew = aggregate(facrecs::ListPairs{<:AbstractString,FacultyRecord}, mergepairs)\n\nAggregate faculty records, merging program from => to pairs from mergepairs.\n\n\n\n\n\n","category":"method"},{"location":"api/#AdmissionTargets.calibrate_service","page":"API","title":"AdmissionTargets.calibrate_service","text":"sc = calibrate_service(progsvc, yrthresh = <7 years ago today>)\n\nCalculate an equivalence between different forms of service. This is to handle the fact that young programs don't provide opportunities for service in the form of thesis commmittees. progsvc is from program_service, and yrthresh selects \"old\" programs (ones that existed prior to yrthresh) useful for calibration.\n\nsc allows a calculation of total service based on the maximum score computed from interviews or from committees.\n\n\n\n\n\n","category":"function"},{"location":"api/#AdmissionTargets.faculty_affiliations","page":"API","title":"AdmissionTargets.faculty_affiliations","text":"naffil = faculty_affiliations(facrecs, scheme)\n\nCompute the number of affiliations per program. facrecs is a list of facultyname::String => facrec::FacultyRecord pairs containing details about the affiliations of each faculty member (see FacultyRecord). facrecs can be read via read_faculty_data.\n\nscheme controls the weighting of affiliations for faculty members with more than one affiliation:\n\n:primary (default): count only the faculty member's primary affiliation (one vote/faculty)\n:all: count all affiliations (multiple votes/faculty depending on the number of affiliations)\n:normalized: one vote per faculty, spread equally among all that faculty member's affiliations\n:weighted: one vote per faculty, with decreasing weight. For a faculty member with 3 affiliations, they would be assigned a ratio of 3 to 2 to 1.  Hence the primary program would get 3/6=0.5, secondary 2/6=0.33, and tertiary 1/6=0.17.\n\n\n\n\n\n","category":"function"},{"location":"api/#AdmissionTargets.faculty_effort-Tuple{Union{AbstractDict{var\"#s48\", FacultyRecord}, AbstractArray{Pair{var\"#s48\", FacultyRecord}, 1}} where var\"#s48\"<:AbstractString, AbstractRange{var\"#s49\"} where var\"#s49\"<:Union{Dates.Date, Integer}}","page":"API","title":"AdmissionTargets.faculty_effort","text":"faculty, programs, E = faculty_effort(facrecs, daterange::AbstractRange; sc=nothing, progrange=<default>)\n\nUse facrecs, a list of facultyname::String => facrec::FacultyRecord pairs, to estimate the average annual effort (in hours) contributed in the forms of service tracked in Service. See FacultyRecord and read_faculty_data. daterange specifies the time span covered by facrecs; it could be a Date range or something like 2016:2020 to indicate a span in calendar years. The optional sc allows you to supply a service calibration, see calibrate_service. progyears lets you supply a Dict(progname => yearrange) specifying the duration of existence of each program; the default effectively assumes you've called aggregate on facrecs to consolidate defunct programs into their modern equivalents.\n\nOn output, E is a length(faculty)-by-length(programs) matrix, where E[j,i] measures the average annual effort committed by faculty member faculty[j] to programs[i].\n\n\n\n\n\n","category":"method"},{"location":"api/#AdmissionTargets.faculty_involvement-Tuple{AbstractMatrix{T} where T}","page":"API","title":"AdmissionTargets.faculty_involvement","text":"f = faculty_involvement(E::AbstractMatrix; scheme=:normeffort, annualthresh=3, M=size(E,1))\n\nCompute the effective number of faculty f[i] involved in program i, based on annual effort E as computed by faculty_effort. annualthresh is the number of hours that must be exceeded in order to qualify as a contributing faculty member.\n\nThere are three schemes available:\n\n:thresheffort: f[i] gets a +1 contribution from faculty member j if j exceeded annualthresh in that program. (This allows one faculty member to count multiple times.)\n:normeffort (the default): for each faculty member who's total service hours across all programs exceeds annualthresh, distribute a total of one vote in proportion to service per program.\n:effortshare: calculate the average service per faculty member (M faculty members total) for each program. If a faculty member exceeded this threshold for k programs, add 1/k to each. annualthresh plays no role here.\n\n\n\n\n\n","category":"method"},{"location":"api/#AdmissionTargets.program_service-Tuple{Union{AbstractDict{var\"#s4\", FacultyRecord}, AbstractArray{Pair{var\"#s4\", FacultyRecord}, 1}} where var\"#s4\"<:AbstractString}","page":"API","title":"AdmissionTargets.program_service","text":"progsvc = program_service(facrecs)\n\nCompute the total service for each program. progsvc is a Dict(progname => ::Service).\n\n\n\n\n\n","category":"method"},{"location":"api/#AdmissionTargets.read_faculty_data-Tuple{AbstractString, Vararg{Any, N} where N}","page":"API","title":"AdmissionTargets.read_faculty_data","text":"facrecs = readfacultydata(filename)\n\nRead faculty training participation from a file. See \"/home/runner/work/AdmissionSuite.jl/AdmissionSuite.jl/AdmissionTargets/src/test/data/facultyinvolvement.csv\" for an example of the format.\n\n\n\n\n\n","category":"method"},{"location":"api/#AdmissionTargets.targets-NTuple{4, Any}","page":"API","title":"AdmissionTargets.targets","text":"tgts, parameters = targets(program_napplicants, program_nfaculty, N, minslots)\n\nCompute the target number of matriculants for each program, reserving some slots to ensure that no program gets fewer than minslots. Slots are assigned via a \"hyperbolic\" parametrization:\n\nn_i = sqrtn_0^2 + fracN^prime^2 w_i^2W^2\n\nn₀ and N′ are parameters computed to ensure that the minimum nᵢ (across all programs) is equal to minslots, and the sum of slots is N. wᵢ is the weight assigned to the ith program and is extracted from program_nfaculty, and W² = ∑ᵢ wᵢ^2. Very small programs might receive most of their slots from n₀, whereas large programs receive approximately a fraction N′/N < 1 of the slots they would otherwise receive without minslots.\n\nThis \"hyperbolic\" approach provides graded program-leveling, reserving the largest boost for small programs. It does not have sharp cutoffs: even programs that would have received barely more than minslots still get some boost.\n\n\n\n\n\n","category":"method"},{"location":"api/#AdmissionTargets.targets-Tuple{Any, Any, Any}","page":"API","title":"AdmissionTargets.targets","text":"tgts = targets(program_napplicants, program_nfaculty, N)\n\nCompute the target number of matriculants for each program. program_napplicants is a collection of program => napplicants pairs; program_nfaculty is a collection of program => nfaculty scores (see faculty_affiliations and faculty_involvement). N is the total number of matriculants across all programs.\n\nEach program gets weighted by the geometric mean of the # of applicants and faculty. In other words, each program gets\n\nn_i = N fracsqrta_i f_isum_k sqrta_k f_k\n\nslots.  On output, tgts[program] is the number of slots for program.\n\n\n\n\n\n","category":"method"},{"location":"simulation/#Offer-extension-and-outcome-forecasts","page":"Offers","title":"Offer extension and outcome forecasts","text":"","category":"section"},{"location":"simulation/","page":"Offers","title":"Offers","text":"This page explains the internal workings of the package.","category":"page"},{"location":"simulation/","page":"Offers","title":"Offers","text":"This package uses past applicants as proxies for current applicants to make predictions about whether they'll accept the offer. Because two \"similar\" students might end up making different final decisions, the recommended practice is to identify many different potential proxies and use the distribution of their decisions to simulate future outcomes.  This is similar to a k-nearest neighbors algorithm, but with continuous weights applied to each potential neighbor and no limit on the number of neighbors used.","category":"page"},{"location":"simulation/","page":"Offers","title":"Offers","text":"The inputs to this process are:","category":"page"},{"location":"simulation/","page":"Offers","title":"Offers","text":"records on previous applicants\ncriteria for deciding the similarity between two students, resulting in a matching function computing a value between 0 (no match) and 1 (a perfect match).","category":"page"},{"location":"simulation/","page":"Offers","title":"Offers","text":"The core concept may be easily explained by a simplified example. Imagine that the admissions committee for \"program A\" has ranked their applicants for the season. Let's focus on one \"test\" applicant, say their 2nd most highly-ranked applicant. Let's imagine that the history of past admissions seasons looks like the first four columns below:","category":"page"},{"location":"simulation/","page":"Offers","title":"Offers","text":"Applicant Program Applicant rank Accepted? Similarity to test applicant\nPastApplicant1 A 1 no 0.6\nPastApplicant2 A 2 yes 1.0\nPastApplicant3 A 3 no 0.6\nPastApplicant4 A 4 yes 0.4\nPastApplicant5 B 1 yes 0.1\nPastApplicant6 B 2 no 0.15","category":"page"},{"location":"simulation/","page":"Offers","title":"Offers","text":"The final column is specific to this particular \"test\" applicant–the one being made an offer in the current season whose response to the offer of admission is currently unknown–and must be recomputed for each current applicant we want to examine. The idea is that we look at all previous applicants who were also offered admission and assess similarity. In this table, 4 of the applicants are also from \"program A.\" These are viewed as being especially similar to the test applicant, particularly the applicant who was also the 2nd most highly-ranked applicant in zir year (with a similarity score of \"1.0\"). However, in this case our matching function also allows us to use \"intelligence\" from other programs, and so two applicants to \"program B\" have a small but nonzero similarity to the test applicant.","category":"page"},{"location":"simulation/","page":"Offers","title":"Offers","text":"Now, to make predictions about how our test student will respond to our offer, we form a similarity-weighted sum of the previous yes/no decisions. In this case, the probability of \"yes\" is (1.0 + 0.4 + 0.1)/(0.6 + 1.0 + 0.6 + 0.4 + 0.1 + 0.15) ≈ 0.53. This gives us a quantitative assessment of the likelihood that our test applicant will accept our offer. While each individual applicant must ultimately answer either yes or no, the fundamental thesis of this package is that having a per applicant matriculation probability can allow better control over class sizes through management of offer-extensions and wait-lists.","category":"page"},{"location":"simulation/","page":"Offers","title":"Offers","text":"The actual model incorporates more factors than shown in this simplified example. For example, we track the date on which each past applicant informed us of zir decision. This allows us to account for the ways in which both applicant and program competitiveness may interact to lead some applicants to respond immediately to our offer of admission and others to wait until the last day of the season (typically April 15th), with the reasons for delay also being coupled to the likelihood of accepting the offer of admission (e.g., more \"yes\" decisions arrive early and more \"no\" decisions arrive late). Accounting for these additional factors in our similarity computation improves accuracy in the projections for managing the wait list.","category":"page"},{"location":"simulation/","page":"Offers","title":"Offers","text":"The remainder of this documentation describes the actual implementation.","category":"page"},{"location":"simulation/#Applicant-records","page":"Offers","title":"Applicant records","text":"","category":"section"},{"location":"simulation/","page":"Offers","title":"Offers","text":"Records on previous applicants are in two forms: very general information is stored in program_history, a dictionary recording just a few bits of information for each program. For example:","category":"page"},{"location":"simulation/","page":"Offers","title":"Offers","text":"    program_history = Dict(ProgramKey(season=2021, program=\"NS\") => ProgramData(slots=15, napplicants=302, firstofferdate=Date(\"2021-01-13\"), lastdecisiondate=Date(\"2021-04-15\")),\n                           ProgramKey(season=2021, program=\"CB\") => ProgramData(slots=5,  napplicants=160, firstofferdate=Date(\"2021-01-6\"),  lastdecisiondate=Date(\"2021-04-15\")))\n","category":"page"},{"location":"simulation/","page":"Offers","title":"Offers","text":"suffices to record aggregate data for two programs, \"NS\" and \"CB\", during the 2021 season (corresponding to a decision deadline of April 15, 2021). This records the target number of matriculants (slots), the total number of applications received, the date of the very first offers extended, and the date on which a decision was due.","category":"page"},{"location":"simulation/","page":"Offers","title":"Offers","text":"Valid choices for program names are listed in Admit.program_lookups; internally the code always uses the abbreviation, but it is possible to supply it in long form too.","category":"page"},{"location":"simulation/","page":"Offers","title":"Offers","text":"Detailed applicant records only need to include applicants to whom an offer of admission was extended. The requirements are described by NormalizedApplicant(applicant; program_history).","category":"page"},{"location":"simulation/","page":"Offers","title":"Offers","text":"You can load both the program history and data on applicants using read_program_history and read_applicant_data.","category":"page"},{"location":"simulation/#Match-criteria","page":"Offers","title":"Match criteria","text":"","category":"section"},{"location":"simulation/","page":"Offers","title":"Offers","text":"Applicants 1 and 2 are matched by the following function:","category":"page"},{"location":"simulation/","page":"Offers","title":"Offers","text":"phi(p_1 p_2) psi(r_1-r_2 t_1-t_2)","category":"page"},{"location":"simulation/","page":"Offers","title":"Offers","text":"phi(p_1 p_2) is a measure of similarity between the two applicants' programs, p_1 and p_2, based on program selectivity and yield. The psi term is applicant-specific, analyzing rank r and date t on which the offer of admission was made.","category":"page"},{"location":"simulation/","page":"Offers","title":"Offers","text":"In the current implementation, programs are compared by selectivity s and yield y. Selectivity is simply the fraction of applicants who receive offers of admission; yield is more complicated, because the proper handling of the wait list requires not just an estimate of how many applicants accept our offer, but also the typical timing with which they accept.  A program that ranks first in the world (or one whose admissions committee targets a lot of high-certainty applicants to reduce their risk of receiving rejections) might imagine receiving a lot of \"yes\" replies as soon as offers are extended, whereas a program with a lot of competition might have a larger number of delayed responses.  Consequently, by default the admissions season is broken into thirds, and the fraction of accepts/declines in each third is the basis for comparing yield in two programs. The formula for doing this is","category":"page"},{"location":"simulation/","page":"Offers","title":"Offers","text":"phi(p_1 p_2) = expleft(-frac(s_1 - s_2)^22sigma_textsel^2 - frac(bf y_1 - bf y_2)^22sigma_textyield^2right)","category":"page"},{"location":"simulation/","page":"Offers","title":"Offers","text":"Here, bf y is a vector encoding the fraction of accepts/declines in each period of the season, and a Euclidean distance is computed.","category":"page"},{"location":"simulation/","page":"Offers","title":"Offers","text":"The sigma parameters measure the standard deviation, i.e., the tolerance for mismatch (larger sigma are more tolerant of mismatch). In the extreme of sigma ll 1, each program matches only itself; in the extreme sigma gg 1, each program matches every other program perfectly.  In between, programs will draw more \"intelligence\" from other programs with similar selectivity and yield dynamics as their own. In practice, model-tuning (see below) seems to favor programs primarily relying on their own history.","category":"page"},{"location":"simulation/","page":"Offers","title":"Offers","text":"The remaining terms are applicant-, rather than program-, specific:","category":"page"},{"location":"simulation/","page":"Offers","title":"Offers","text":"psi(r_1-r_2 t_1-t_2) = expleft( - frac(r_1 - r_2)^22 sigma_r^2 - frac(t_1 - t_2)^22 sigma_t^2right)","category":"page"},{"location":"simulation/","page":"Offers","title":"Offers","text":"r refers to the normalized ranks and t to the normalized offer date. Smaller sigma_r increases the importance of choosing applicants of similar rank, and would indicate that there may be a strong rank-dependent element to recruitment (e.g., \"more competitive applicants are harder to recruit\"). Smaller sigma_t increases the importance of the timing of the offer, and would indicate that wait-list offers should be treated quite differently from initial offers. The units of both sigma parameters are those of the NormalizedApplicants, i.e., with values ranging between 0 and 1. For example, setting sigma_t = 02 would, in essence, break the decision period (e.g., mid-January to April 15th) into roughly 5 periods, and match primarily against applicants who were extended offers during the same period; conversely, setting sigma_t = 5 would mean that the timing of the offer is essentially irrelevant to predicting the decision. Note that the applicant ranks will typically be quite heavily weighted to low values (e.g., a program that only accepts the top 20% of applicants will only exhibit ranks between 0.0 and 0.2), and as a consequence sigma_r must be smaller than this span to have large effect.","category":"page"},{"location":"simulation/","page":"Offers","title":"Offers","text":"One crucial point is that the matching function returns zero when comparing against past applicants who had already returned their decision by this point in the admissions season. This models the currently-undecided applicants solely in terms of prior applicants who were also undecided at this point. See match_function for specific details.","category":"page"},{"location":"simulation/","page":"Offers","title":"Offers","text":"How does one tune these parameters? The core idea is to train them based on past admissions seasons: if you have records extending back several years, you make matriculation predictions for year y based on data from all years up to and including year y-1, and then compute a correlation with the actual outcome. See match_correlation for details.","category":"page"},{"location":"simulation/#Analysis-and-simulations","page":"Offers","title":"Analysis and simulations","text":"","category":"section"},{"location":"simulation/","page":"Offers","title":"Offers","text":"Once you've entered student records and defined a matching function, then for each outstanding offer you can compute the match likelihood of previous applicants using match_likelihood. The sum of the returned list is a rough measure of the \"number\" of prior applicants deemed to be a good match for the applicant you are modeling; if this value is small, your criteria for matching may be too stringent. Conversely, if this value is approximately equal to the total number of prior applicants, you're essentially treating all students as equivalent (and matching all of them).","category":"page"},{"location":"simulation/","page":"Offers","title":"Offers","text":"Once the likelihood is computed, matriculation_probability estimates the probability that the given applicant will accept an offer. select_applicant allows you to randomly sample these by likelihood, and may serve as the basis for running simulations about outcomes, although run_simulation (which just uses matriculation probability) may be a more useful approach.","category":"page"},{"location":"web/#Web-application-to-manage-the-admissions-season","page":"Web application","title":"Web application to manage the admissions season","text":"","category":"section"},{"location":"web/","page":"Web application","title":"Web application","text":"The web application can run locally on an ordinary laptop or desktop machine. It should be configured for your programs and have access to the database of applicant records and program history (see AdmitConfiguration). Once the web application is running, type the URL into a browser window; if you're running the application on your local machine, this is just http://localhost:8050","category":"page"},{"location":"web/","page":"Web application","title":"Web application","text":"Launching the webapp shows something like the following (fake applicant data were used for these screenshots):","category":"page"},{"location":"web/","page":"Web application","title":"Web application","text":"(Image: summary)","category":"page"},{"location":"web/","page":"Web application","title":"Web application","text":"The application opens on the \"Summary\" tab, which gives an overview across all programs. In the top right, you can adjust the target (if needed) and update the status of applicants from the database by clicking the \"Refresh applicants\" button. The report shows the current estimated class size (mean ± stddev) along with the overall state of each program. \"# accepts\" and \"# declines\" are counts of applicants who have received an offer and already rendered their decision; \"# pending\" is the number of offers that have been issued to candidates who have not yet made a decision. \"# unoffered\" is the number of students on the wait-list. \"Priority\" is a measure of the priority of each program in receiving offers, given the current state; higher numbers indicate greater urgency in extending additional offers from the wait list.","category":"page"},{"location":"web/","page":"Web application","title":"Web application","text":"If you scroll down the page, you'll see something like the following:","category":"page"},{"location":"web/","page":"Web application","title":"Web application","text":"(Image: summary)","category":"page"},{"location":"web/","page":"Web application","title":"Web application","text":"This is the list of wait-listed candidates to whom the algorithm suggests extending offers immediately. Typically this may be empty or just a few students, if the bulk of offers have already been extended. If you offer admission to these candidates, once the database is updated, click \"Refresh applicants\" to update the current status and projections. Note that projections are generated by simulation, and differences across simulation runs introduces a small element of randomness, so you may see subtle changes each time you click \"Refresh applicants.\"","category":"page"},{"location":"web/","page":"Web application","title":"Web application","text":"Clicking on the program tab reveals more information about candidates for a specific program, as chosen by the dropdown at the top-right (here \"MCB\"):","category":"page"},{"location":"web/","page":"Web application","title":"Web application","text":"(Image: program)","category":"page"},{"location":"web/","page":"Web application","title":"Web application","text":"This shows candidates who have accepted or rejected the offer of admission, along with a predicted matriculation probability for each undecided applicant.","category":"page"},{"location":"web/","page":"Web application","title":"Web application","text":"Finally, \"Internals\" provides information about the model details, currently just the \"Program similarity\" score which expresses the use of cross-program data in predicting matriculation probability:","category":"page"},{"location":"web/","page":"Web application","title":"Web application","text":"(Image: internals)","category":"page"},{"location":"installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation/#Install-Julia","page":"Installation","title":"Install Julia","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"AdmissionSuite is written in Julia, a free, modern, high-performance language that excels for analytics and machine learning. Visit the Downloads page and install either:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"the \"LTS\" = \"Long Term Support\" version (recommended)\nthe current stable release","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Pick the appropriate version for your computer (unless you know otherwise, you should choose the \"64-bit\" version).","category":"page"},{"location":"installation/#Launch-Julia-and-add-this-package","page":"Installation","title":"Launch Julia and add this package","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"Unlike most Julia packages you'd use, this one is not \"registered,\" so the line to add this package is slightly more complex. After starting Julia, you should see something like this:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"(Image: launch)","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"At that point, hit ']' to enter \"package mode\":","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"(Image: packagemode)","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Then enter the following line:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"add https://github.com/timholy/AdmissionSuite.jl.git","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"You should see something that starts like this:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"(Image: addpkg)","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"(There may be small details that differ, and that's OK.) After the wheels stop spinning, your package is installed.","category":"page"},{"location":"targets/#Calculating-admission-targets","page":"Targets","title":"Calculating admission targets","text":"","category":"section"},{"location":"targets/","page":"Targets","title":"Targets","text":"Given a target total number of students, here the task is to allocate the number for each program.  We assign these based on two factors,  the number of applicants and the number of training faculty, with no attempt to give bonuses for \"applicant quality\" as this is difficult to measure in an unbiased way.","category":"page"},{"location":"targets/","page":"Targets","title":"Targets","text":"While the number of applicants is unambiguous, it is less straightforward to count faculty because they may participate in multiple programs.  There are two major categories of algorithms supported:","category":"page"},{"location":"targets/","page":"Targets","title":"Targets","text":"counting faculty based on program affiliation (e.g., primary, secondary, and tertiary program affiliations for each faculty member, where secondary and tertiary are optional)\ncounting faculty based on their training service, specifically in the forms of admissions interviews and thesis committees","category":"page"},{"location":"targets/","page":"Targets","title":"Targets","text":"Each category has multiple sub-options. Data for both is provided in the form of a FacultyRecord.","category":"page"},{"location":"targets/","page":"Targets","title":"Targets","text":"Among the choices below, the recommended algorithm is called NormEffort.","category":"page"},{"location":"targets/#Faculty-records","page":"Targets","title":"Faculty records","text":"","category":"section"},{"location":"targets/","page":"Targets","title":"Targets","text":"Faculty records are stored in the following format:","category":"page"},{"location":"targets/","page":"Targets","title":"Targets","text":"julia> using AdmissionTargets, Dates\n\njulia> facrecs = [\n           \"Last1, First1\" => FacultyRecord(Date(\"2011-10-01\"), [\"BBSB\", \"CSB\"], [\"BBSB\" => Service(11, 3), \"MMMP\" => Service(1, 0)]),\n           \"Last2, First2\" => FacultyRecord(Date(\"2018-05-31\"), [\"EEPB\", \"CSB\"], [\"EEPB\" => Service(8, 2)])\n       ];","category":"page"},{"location":"targets/","page":"Targets","title":"Targets","text":"This records the date on which the faculty member became an active member of DBBS, the program affiliations, and the total Service to each program.  In the example above, both faculty members have a secondary affiliation with \"CSB\" but neither has yet done service for the program.","category":"page"},{"location":"targets/","page":"Targets","title":"Targets","text":"Faculty records can be parsed from spreadsheets using read_faculty_data.","category":"page"},{"location":"targets/#Affiliation-based-measures","page":"Targets","title":"Affiliation-based measures","text":"","category":"section"},{"location":"targets/","page":"Targets","title":"Targets","text":"Affiliations are counted with faculty_affiliations:","category":"page"},{"location":"targets/","page":"Targets","title":"Targets","text":"julia> f = faculty_affiliations(facrecs, :primary)\nDict{String, Float32} with 2 entries:\n  \"EEPB\" => 1.0\n  \"BBSB\" => 1.0","category":"page"},{"location":"targets/","page":"Targets","title":"Targets","text":"The two faculty members had primary affiliations of BBSB and EEPB, respectively, so each gets counted as having one faculty member each; while two listed CSB as a secondary affiliation, with :primary these are not counted.","category":"page"},{"location":"targets/","page":"Targets","title":"Targets","text":"There are several other options, for example","category":"page"},{"location":"targets/","page":"Targets","title":"Targets","text":"julia> f = faculty_affiliations(facrecs, :normalized)\nDict{String, Float32} with 3 entries:\n  \"EEPB\" => 0.5\n  \"CSB\"  => 1.0\n  \"BBSB\" => 0.5","category":"page"},{"location":"targets/","page":"Targets","title":"Targets","text":"With :normalized, a faculty member with n affiliations contributes 1/n to each. Other options include :all and :weighted.","category":"page"},{"location":"targets/","page":"Targets","title":"Targets","text":"Among affiliation-based measures, the recommended default is :primary because this is the only choice which yields consistent answers under program mergers and splits.","category":"page"},{"location":"targets/#Effort-based-measures","page":"Targets","title":"Effort-based measures","text":"","category":"section"},{"location":"targets/","page":"Targets","title":"Targets","text":"The other main category of algorithm attempts to gauge capacity and enthusiasm for training based on actual service.  While the reliance on proven investment has several attractions,  it is worth noting that these algorithms can have the tendency to preserve any status quo since service opportunities are in proportion to the number of students.","category":"page"},{"location":"targets/","page":"Targets","title":"Targets","text":"To compute total faculty effort, we first compute an \"effort matrix\" for each faculty/program pair:","category":"page"},{"location":"targets/","page":"Targets","title":"Targets","text":"julia> faculty, programs, E = faculty_effort(facrecs, 2016:2020);\n\njulia> faculty\n2-element Vector{String}:\n \"Last1, First1\"\n \"Last2, First2\"\n\njulia> programs\n3-element Vector{String}:\n \"BBSB\"\n \"EEPB\"\n \"MMMP\"\n\njulia> E\n2×3 Matrix{Float32}:\n 8.19102   0.0     0.199781\n 0.0      10.8034  0.0","category":"page"},{"location":"targets/","page":"Targets","title":"Targets","text":"E[j,i] corresponds to faculty[j] and programs[i].","category":"page"},{"location":"targets/","page":"Targets","title":"Targets","text":"From here one can compute total number of faculty per program via faculty_involvement:","category":"page"},{"location":"targets/","page":"Targets","title":"Targets","text":"julia> f = faculty_involvement(E)\n3-element Vector{Float32}:\n 0.97619045\n 1.0\n 0.023809522","category":"page"},{"location":"targets/","page":"Targets","title":"Targets","text":"This essentially means that BBSB has 0.98 faculty members (98% of \"Last1, First1\"'s effort, in hours, went to BBSB), EEPB has 1 (based on \"Last2, First2\"), and MMMP has 0.02 (based on 2% of the effort of \"Last1, First1\").","category":"page"},{"location":"targets/","page":"Targets","title":"Targets","text":"This too has several options; :normeffort is the recommended default as the only choice that is invariant under program mergers and splits.","category":"page"},{"location":"targets/#Target-computation","page":"Targets","title":"Target computation","text":"","category":"section"},{"location":"targets/","page":"Targets","title":"Targets","text":"Having made a choice about how to assess the number of faculty, we can now compute the target number of \"slots\" (desired number of matriculants) per program:","category":"page"},{"location":"targets/","page":"Targets","title":"Targets","text":"julia> targets(Dict(\"BBSB\" => 86, \"CSB\" => 90, \"EEPB\" => 47, \"MMMP\" => 139), Dict(zip(programs, f)), 12)\nDict{String, Float32} with 4 entries:\n  \"EEPB\" => 4.61209\n  \"CSB\"  => 0.0\n  \"BBSB\" => 6.16404\n  \"MMMP\" => 1.22386","category":"page"},{"location":"targets/","page":"Targets","title":"Targets","text":"The first argument is the number of applicants per program, the second the \"number\" of faculty per program, and the third the total number of slots available.  In this simple example, f was computed from faculty_involvement and no faculty in our example list provided service to \"CSB\", so that program was awarded no slots.  Under more realistic circumstances with hundreds of faculty engaged in many different ways, the slot computation reflects the aggregate affiliations or involvement across programs.","category":"page"},{"location":"targets/","page":"Targets","title":"Targets","text":"You can also impose a minimum number of slots per program:","category":"page"},{"location":"targets/","page":"Targets","title":"Targets","text":"julia> tgts, parameters = targets(Dict(\"BBSB\" => 86, \"CSB\" => 90, \"EEPB\" => 47, \"MMMP\" => 139), Dict(zip(programs, f)), 12, 2);\n┌ Warning: The following programs 'earned' less than one slot (give them notice): [\"CSB\", \"MMMP\"]\n└ @ AdmissionTargets ~/.julia/dev/AdmissionSuite/AdmissionTargets/src/targets.jl:267\n\njulia> tgts\nDict{String, Float64} with 4 entries:\n  \"EEPB\" => 3.51217\n  \"CSB\"  => 2.0\n  \"BBSB\" => 4.34612\n  \"MMMP\" => 2.14171\n\njulia> parameters\n(n0 = 2.0, N′ = 7.511807630635848)","category":"page"},{"location":"targets/","page":"Targets","title":"Targets","text":"The floor is imposed without going over the total of 12 slots, and so while it boosts the smallest programs it takes slots away from the larger ones. By default, a warning is issued for any program that \"earns\" less than a single slot, but this can be suppressed by adding iswarn=false to the call to targets. params describes the parameters used in the overall model, which is described in targets(program_napplicants, program_nfaculty, N, minslots).","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"CurrentModule = AdmitConfiguration","category":"page"},{"location":"configuration/#AdmitConfiguration","page":"Configuration","title":"AdmitConfiguration","text":"","category":"section"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"Configuring AdmissionSuite is more complex than for typical packages (most of which require no configuration at all). To work seamlessly with your admissions system, it must","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"know the names and some information about the programs for which you are offering admissions\nbe able to connect to your database of applicants and run queries\nbe able to parse the tables in whatever format your institution has chosen for representing the data (this step will likely require you to write a few lines of Julia code)\nif your interest is in the web application, you may want to configure your system so the web application gets launched by starting Julia","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"Each of these requires custom configuration. If these seem daunting, seek help from a local Julia user or contact Tim Holy (WashU) for assistance.","category":"page"},{"location":"configuration/#progconfig","page":"Configuration","title":"Configuring your programs","text":"","category":"section"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"info: Info\nThis step only needs to be performed once when you first use Admit or AdmissionTargets. If you restructure your programs, you'll want to reconfigure to match the current programs.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"Using a spreadsheet program, create a table that, at a minimum, has a single column called Abbreviation and more comprehensively may have some or all of the following columns:","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"(Image: programs)","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"The Abbreviation column must list all your programs. This should be whatever \"tag\" you like to use to refer to each program, and should not be too long as it will need to fit in dropdown boxes in Admit. Full names can optionally be listed in ProgramName, and indeed this must be set if your database stores records by full program names. For the remaining columns, see the documentation on set_programs.  If you need a complete example, see the file examples/WashU.csv within this package repository.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"Once done, save the table in Comma-separated value (CSV) format using your spreadsheet program's \"Save as\" or \"Export\" functionality. Then, in Julia execute the following set of statements:","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"julia> using AdmissionSuite, AdmissionSuite.AdmitConfiguration\n\njulia> set_programs()","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"There may be a brief delay (Julia code compiles when you first run it, and this can sometimes take some time), after which it will prompt you to find and select the CSV file.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"tip: Tip\nAlternatively, you can pass the file name as a string, set_programs(\"/path/to/file.csv\").  Note that on Windows, \\ needs to be treated specially in strings, but you can write file paths using \"raw strings,\" e.g., set_programs(raw\"C:\\Documents\\Admissions\\AdmissionSuite\\program_configuration.csv\")).","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"If it returns without error, the process worked. You are now done configuring your programs.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"tip: Tip\nYou can check that it worked by typing program_abbreviations at the julia> prompt: you should see a list of the programs you just defined.","category":"page"},{"location":"configuration/#dbconfig","page":"Configuration","title":"Configuring database access","text":"","category":"section"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"info: Info\nThis step only needs to be performed once to establish connectivity to your SQL database. If you change your server URL or other features, you may need to redo these steps.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"Admit can directly query applicant records through a SQL interface. This has been tested on Windows, but may work with small modifications on Mac and Linux.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"To use this feature, several configuration steps are required. Most of these may not be necessary if you are running Admit from a machine that can already access your database.","category":"page"},{"location":"configuration/#conncheck","page":"Configuration","title":"If your machine already has access to the database","text":"","category":"section"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"If your system can already access the SQL database via a \"Data Source Name\" (DSN), just check whether you have access from Julia:","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"julia> using AdmissionSuite, AdmissionSuite.AdmitConfiguration\n\njulia> conn = connectdsn(<dsnname>)","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"where you replace <dsnname> with the name of your DSN (for example, connectdsn(\"DBBS\") if you've created a DSN called \"DBBS\"). The syntax above is applicable if your DSN connects via Active Directory (a \"trusted connection\" in SQL parlance); alternatively, use","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"julia> conn = connectdsn(<dsnname>; usepasswd=true)","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"and you will be prompted for your user name and password before attempting to connect to the SQL server.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"If this returns without an obvious error, all is well and you can skip below to the section on setting up automatic connections.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"warning: Warning\nWhile it's possible to store your username and password in your DSN configuration, this is a security hole and not recommended.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"If you do not already have access via a DSN, the next sections describe how to configure it.","category":"page"},{"location":"configuration/#driver","page":"Configuration","title":"Installing an ODBC driver","text":"","category":"section"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"If necessary, install the SQL Server ODBC driver.","category":"page"},{"location":"configuration/#Windows","page":"Configuration","title":"Windows","text":"","category":"section"},{"location":"configuration/#Other-platforms","page":"Configuration","title":"Other platforms","text":"","category":"section"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"From the link above, download the MSODBC package for your platform and install it\nFind the library file on your system. At least on Linux, the file will contain \"libmsodbcsql\" in the name. Library files have dll, dylib, or so in their extension.\nStart Julia and execute the following:","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"julia> using AdmissionSuite\n\njulia> libpath = \"/opt/microsoft/msodbcsql17/lib64/libmsodbcsql-17.4.so.1.1\"\n\njulia> ODBC.adddriver(\"MSODBC\", libpath)","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"where libpath should be the path to the library on your own system.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"Now \"MSODBC\" is a shortcut for the actual driver library.","category":"page"},{"location":"configuration/#Configuring-the-Data-Source-(DSN)","page":"Configuration","title":"Configuring the Data Source (DSN)","text":"","category":"section"},{"location":"configuration/#From-within-the-ODBC-configuration-utility-(Windows)","page":"Configuration","title":"From within the ODBC configuration utility (Windows)","text":"","category":"section"},{"location":"configuration/#From-within-Julia","page":"Configuration","title":"From within Julia","text":"","category":"section"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"This approach can be used on non-Windows platforms. After installing the driver, execute","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"julia> using AdmissionSuite    # not needed if you've already done this in the same session\n\njulia> ODBC.adddsn(<dsnname>, \"MSODBC\"; SERVER=<SQL server URL>, DATABASE=<database name>)","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"The items between <> are items you need to fill in. For example, for WashU's DBBS the line looks something like this:","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"julia> ODBC.adddsn(\"DBBS\", \"MSODBC\"; SERVER=\"someurl.wustl.edu\", DATABASE=\"DBBS\")","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"Now, <dnsname> (\"DBBS\" in the example above) is a shortcut for the DSN.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"warning: Warning\nPutting your user name and password into the DSN configuration is a security hole and not recommended.","category":"page"},{"location":"configuration/#Checking-your-setup","page":"Configuration","title":"Checking your setup","text":"","category":"section"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"Check your connection described above.","category":"page"},{"location":"configuration/#automatic","page":"Configuration","title":"Making your connection automatic","text":"","category":"section"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"Once you have a DSN, use","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"julia> using AdmissionSuite, AdmitConfiguration\n\njulia> set_dsn(<dnsname>)","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"Henceforth Admit will connect to the database as needed, all you have to do is respond to password prompts.","category":"page"},{"location":"configuration/#tblconfig","page":"Configuration","title":"Configuring your data tables","text":"","category":"section"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"Once you can connect to the database, the final step is to configure the ability to extract information from the tables within it. Interally, AdmissionSuite converts the table into a DataFrame, which is similar to a spreadsheet. AdmissionSuite needs to know the names of the columns from which it can extract particular pieces of information.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"Extractors come in two flavors: \"by name\" and \"custom function\". The latter are used in more complex situations where you might need to reference multiple columns in order to extract a particular item.","category":"page"},{"location":"configuration/#\"By-name\"-columns","page":"Configuration","title":"\"By name\" columns","text":"","category":"section"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"\"By name\" configuration is done with set_column_configuration; see its documentation for details.","category":"page"},{"location":"configuration/#\"Custom-function\"-configuration","page":"Configuration","title":"\"Custom function\" configuration","text":"","category":"section"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"These require that you write a few Julia functions and save them to a file. You then register these functions with set_local_functions; see its documentation for details about which functions need to be implemented and examples of how to write them.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"If this step is daunting, seek help from a local Julia user or contact Tim Holy (WashU) for assistance.","category":"page"},{"location":"configuration/#Testing-your-configuration","page":"Configuration","title":"Testing your configuration","text":"","category":"section"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"To test your entire setup, try the following:","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"julia> using AdmissionSuite, AdmissionSuite.AdmitConfiguration, AdmissionSuite.Admit\n\njulia> conn = connectdsn(...)    # fill in \"...\" with whatever worked to connect to your database\n\njulia> applicants, program_history = parse_database(conn);","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"If that throws an error, something about your configuration needs fixing; the error message should hopefully provide some guidance about what is wrong.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"If there is no error, check that the output looks reasonable:","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"julia> applicants","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"should show a list of all applicants, past and present, available from your database.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"tip: Tip\nIf you database contains multiple entries for each applicant (e.g., one for each new status update), instead use parse_database(conn; deduplicate=true) to remove the duplicates. For this to work, you'll have to create the when_updated function among your local functions.","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"Likewise,","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"julia> program_history","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"should show records of your program history.","category":"page"},{"location":"configuration/#webappconfig","page":"Configuration","title":"Launching the web application automatically","text":"","category":"section"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"If you're configuring this for admissions-professional usage, chances are your main interest is the web application. You can configure this to launch automatically by creating a text file with contents:","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"using AdmissionSuite, AdmissionSuite.AdmitConfiguration, AdmissionSuite.Admit\nconn = connectdsn(...)    # fill in \"...\" with whatever worked to connect to your database\nrunweb(conn)              # add any needed keyword arguments like `deduplicate`","category":"page"},{"location":"configuration/","page":"Configuration","title":"Configuration","text":"Save this as ~/.julia/config/startup.jl in the user account (~ means \"user home directory\", if necessary search for the .julia folder on your system). This will launch the web application automatically when Julia starts.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Admit","category":"page"},{"location":"#AdmissionSuite","page":"Home","title":"AdmissionSuite","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"AdmissionSuite is designed to help allocate offers of admission, forecast outcomes, and allocate resources across programs. It was designed around Washington University's Division of Biology and Biomedical Sciences (DBBS), the first cross-departmental graduate training program in the United States consisting of many different programs of study with coordinated admissions and funding.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The suite is organized into three sub-packages:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Admit focuses on managing offers of admission and predicting the probability that candidates will accept them. It includes a browser-based application that can be used by admissions professionals to manage the admissions season.\nAdmissionTargets focuses on allocating \"slots\" among different programs, given a total target number of incoming students.\nAdmitConfiguration is used to configure the suite for your local institution","category":"page"}]
}
